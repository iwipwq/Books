25분마다 5분 쉬기 or 2시간마다 30분 쉬기
자신에게 맞는 속도로 배우세요
몇일 몇년

협업툴을 활용하세요

# 토끼굴의 가장자리

## 블록체인

비트코인 -> bitcoin white paper -> 비트코인의 original vision

사람들이 Superior Digital Store of Value (like gold) 탁월한 자산 가치 저장소(디지털 금광마냥) 로 여겼지만
비트코인의 원래 비전은 bitcoin white paper에 나와있다.

etherium
+ Decentralized Agreements (Smart Contracts)

Nick Szabo (cryptographer)
Smart Contracts are a set of instructions exectued in a decentralized way without the need for a centralized or third party intermediary.

비트코인과 이더리움의 차이점은 smart contract
remove centralized forces and counterparty risk
비트코인도 기술적으로는 samrt contract를 가지고 있지만 "의도적으로 불완전하게" 되어있음
비트코인이 모든 기능을 가지고 있지 않음 ->
관심사 차이 
비트코인 프로토콜-> "value"를 저장하는것
이더리움 프로토콜-> "value"를 저장함과 동시에 탈중앙화를 촉진함

블록체인은 의도적으로 차단되어있음
블록체인은 사실 현실로부터 데이터를 읽거나 듣지 못한다.
The oracle problem

Blockchain Oracle:
Any device that interacts with the off-chain world to provide external data or computation to smart contracts.
체인밖의 세상에서 외부의 데이터나 스마트 컨트렉트를 계산하기 위해 상호작용되는 모든 기기들
블록체인은 하나의 데이터나 하나의 컴퓨테이션으로 작동될 수 없다.
그렇기 때문에 decentralized Oracle Network를 사용함

Hybrid Smart Contracts: On-Chain + Off-chain Agreements
여기서 가장 많이 상호작용할 프로토콜은 Hybrid Smart Contract 일 겁니다.

Chainlink
Decentralized Oracle Network
우리는 "smart contract"와 "hybrid smart contract"를 교대하며 사용할 것입니다.

비트코인 폴렛폼
아발렌체,폴리곤 , 팬텀, 하모니
대부분의 블록체인들이 이더리움 타입의 스마틐컨트렉트에서 작동가능함
따라서 여기서는 Etherium 환경에서 deploy  할 것입니다.
특정 툴이나, 체인을 익힐 걱정을 하지 않아도 됩니다. 왜냐하면 대부분 비슷하게 작동하기 때문입니다.

우리는 스마트컨트랙트 폴렛폼을 사용할때도 있고, 블록체인을 사용할때도 있을겁니다.
Dapp = Decentralized Application = Decentralized Protocol = Smart Contract

Web1: The permissionless open sourced web with static content.
Web2: The permissioned web, with dynamic content. Where companies run your agreements on their servers.
Web3: The permissionless web, with dynamic content. Where decentralized censorship resistant networks run your agreement and code. it generally is accompanied by the idea of user owend ecosystems, where the protocols you interact with you also own a portion of, instead of solely being the product.
웹3: 동적 콘텐츠가 있는 권한 없는 웹입니다. 분산된 검열 저항 네트워크가 당신의 계약과 코드를 실행한다. 일반적으로 사용자 소유 생태계에 대한 아이디어를 수반합니다. 여기서 사용자는 상호 작용하는 프로토콜도 제품이 아닌 일부만 소유합니다.

## smart contarct
### What is the value of smart contracts? 스마트 컨트렉트의 장점은 무엇일까?
이 기술은 어떤 문제점을 해결해 줄 수 있을까요?
기술은 언제나 문제점을 해결하기위해 존재합니다.
블록체인,스마트컨트렉트,암호화폐.... 이 모든것들을 합해서 말 할 수 있는 패러다임이란
이 모든걸 합쳐 스마트컨트렉트가 하는일을 쉽게 말해보자면 
->Trust Minimized Agreement
Unbreakable (Agreement) Promises 깰 수 없는 약속
속도, 효율, 투명성, 등등을 수반하지만 제일 중요한 것은

### undeniable value of smart contract
스마트 컨트렉트의 목적
re-landscape Markets and Agreements.
시장과 계약의 재조성
crypto가 아닌 다른 부분에서!

블록체인의 목적
어릴적 초등학교시절에 하던 깨지지 않는 약속 새끼손가락 걸고 하는 약속과 관계가 있습니다.

Agreements Contracts Promises
여기 당신의 인생에서 동의와 계약 그리고 약속으로 이루어진 결과물이 있습니다.

예를 들어 여기 당신의 의자는 아마존의 기술자가 가구를 만들기 위해 목재를 사기 위해 '동의'한 결과입니다.
그리고 당신은 그걸 40달러에 사는걸 '동의'했습니다.

당신의 집에 있는 전구는, 전기로 작동하고 매일 불을 켤 수 있게 전기회사에서 전기를 받고 돈을 납부하기로 '동의'한 결과입니다. 전기회사에서 생산하는 전기는 전기회사에서 터번을 돌려 전기를 생산하는 기술자과 회사가 동의한 결과입니다.

보험회사에는 당신이 매달 보험금을 내고 보험회사는 ~~아무것도안하죠~~ 당신의 의료보험금 등을 돌려줍니다.

일상생활의 대부분의 것들은 당신의 계약 동의 약속으로 이루어집니다.

Agreements / contracts = Promiese
동의와 계약을 합쳐서 쉽게 부르자면 바로 '약속'입니다.

기름을 교활할때도 과금만큼 기름을 돌려주는걸 약속합니다.
은행에 돈을 넣을때도 안전하게 돈을 보관하고 이자를 쳐서 돌려주는걸 약속합니다.
복권도 복권티켓을 사면 당신에게 당첨될 공정한 기회를 제공함을 약속합니다.

당신이 이 동의를 할때 당신은 동의대상과 이 일에 대해 속이지 않고, 공정하게 대할 것을 새끼 손가락 걸고 약속하는 겁니다. 하지만 늘 이렇진 않죠.

현실에서 이 새끼손가락 걸고 하는 약속을 어기는 경우를 생각해봅시다.

오래전 80~90 년대 맥도날드에서 모노폴리(보드게임)카드를 모으면 돈을 주는 프로모션을 진행했습니다.
쉽게 말하면 맥도날드에서 뭔가를 사면 100만 달러를 얻게 된다는 말이였습니다! 

Hey everbody, I promise if you buy our McFood we'll give you a fair chance of winning the money!

그러나 그들은 이 약속을 어겼습니다.
당첨될 공평한 기회 대신, 사실 당첨될 확률은 '0'이였습니다.
90년대 중반에 $13 ~24 백만 달러를 구입한 사람들이 아닌 회사의 부패한 내부자들이 해쳐먹었습니다.
당신이 맥도날드를 사면 100% 횡령금이 되는 것이였습니다.
이것이 맥도날드의 잘못인지 아닌지 중요하지 않습니다.
그들은 궁극적으로 지키지 못할 약속을 한 것이였습니다.

또 생각해볼 것은 24백만 달러란 돈을 우리들에게서 훔쳐간 것입니다.

하지만 이 서비스가 블록체인에서 배포되었다면 24백만 달러를 횡령하는 일은 절대 불가능했을겁니다. 바로 스마트컨트랙트의 다음과 같은 걸로 말이죠
Imuutable
Decentralized
Transparent

열살 자리 꼬마에게 돈을 맡겨달라는 부탁을 해봤다고 생각해봅시다. 아마 돈을 잃게될까봐 불안해질겁니다.

어떻게 이 사람을 믿을 수 있을까?
혹시 약속을 어기지 않을까?

언제나 이런 불안감들 때문에 숨을 못쉬겠죠

자동차 영업사원이 나에게 좋은 차를 줄지 믿을 수 있을까? 이 세탁기가 내 옷을 잘 빨아줄까 아니면 셔츠를 줄어들게 할까, 혹시 보험회사에서 내가 버스에 치였는데도 약속을 어기고 보험금을 납부하지 않을까?

계약을 하기 위해선 사람들이 옳은 일을 할꺼라고 믿어야 합니다.

작년에만 해도 로빈후드는 사용자들에게 세계금융거래와의 상호작요에 있어서 'Fair chance'를 준다고 선언했었습니다.
HAHA SIKE! 넝담~
AMC, GME, DOGE, NOK ??? (게임스탑사태때 매도버튼을 뽑아버린 걸 말하는듯)

2008년 금융위기를 기억하시나요?
비밀리에 발행된 수상한 부채들이 커다란 금융상품과 결합되어 세계경제를 무너뜨렸습니다.

짐바브웨의 하이퍼인플레이션, 브라질의 하이퍼인플레이션, 테라노스 사건

역사는 우리에게 악명높은 약속을 파기하는 것들의 실체에 대한 교훈을 주고있습니다.

우리는 마침내 이런것들을 smart contract로 고치기를 기다립니다.

이런것들로부터 우리를 지켜줄 여러 제도들이 있지만 가끔 지켜지지 않기도 합니다.
심지어 법정에 개인회생을 신청하러 가서도 3년이 걸릴 수 있고 그 사이에 돈을 구할 방법이 없을지도 모릅니다.

이런 근본적인 문제를 해결하기 위해 무엇을 해야할까요
그것이 바로 Smart Contract이며 blockchain이 만들어진 이유입니다.

스마트 컨트렉트는..
- 분산된(탈중앙화된) 블록체인에 배포된 동의,계약,지시를 말합니다.
- 바뀔(대체 될) 수 없습니다. (불변성)
- 자동으로 실행됩니다.
- 모든사람들이 계약조건을 볼 수 있습니다.

기존의 계약관계에선 중앙에서 계약조건을 마음대로 변경 할 수 있었지만 스마트 컨트렉트에선 불가능합니다.

전통적으로 복권추첨은 비공개로 진행되었습니다.
어떤 사람이 복권을 추첨하고, 코드를 가지고있고 그것을 실행할 수 있었고, 이사람이 어떤걸 조작해도 다른 사람들은 알아차리지 못했습니다.
만약 이 복권시스템이 블록체인환경으로 배포된다면 해커가 시스템을 변경할때마다 모든 사람들이 그것을 알게됩니다. 하지만 해커가 이런일을 하는 자체도 (어떤것을변경하는 일) 불가합니다.
CANNOT BER ALTERED
블록체인은 한번 배포되면 바꿀 수 없기 때문입니다.
impossible to hack
impossible to defraud (사취할 수 없는)
impossible to manipulate

decentralized exchanges
UNISWAP - ERC20 토큰으로 주식구매 가능

Decentralized Finance -> 막대한 금융 손실 감축
은행의 독단적 행동 막을 수 있음

1+1 =3 이 아닌 1+1=2 가 될 수 있도록

DEFI ->$200 Billion
defi movement

trust minimized agreement
ubreakable promises

### Ohter Blockchains benifits
Bitcoin 
이더리움 스마틐컨트렉터 decentralized trust minimized agreement
Chainlink offchain과 onchain 상호작용
스마트컨트렉트는 디지털 오일의 가치가 있다
Smart contract value = Trust Minimized Agreements

1. Decentralized
Many node operators run blockchains
2. Transparency & Flexibility
3. Speed & Efficiency (은행도 수학적으로 작동하지만 몇일걸림 마찬가지로 블록체인도 수학적으로 작동하지만 즉시처리가능함)
4. Security & immutability (데이터를 임의로 변경할 수 없다 / 데이터를 소유할 필요가 없다, 데이터가 소거되어도 모든 데이터는 분산된 노드에 저장되어있다. 수천 수만노드가 중지되어도 문제없다. 오직 하나의 블록체인이 그걸 복사했다면 문제없음, 블록체인을 해킹한다는것은 거의 불가능하다, 중앙화된 시스템을 뜷는것보다 어려움)
5. Counterparty Risk Removal (web2.0의 중개인을 제거하고, 카운터파티 게이트웨이를 제거한다.)
6. Trust minimized agreements (수학적으로 정의되는 파기할 수 없는 약속, 프로토콜의 오너가 될 수 있다.)

## What have Smart Contracts done so far?
- DeFi = Decentralized Finance
공정하고 투명한 금융거래
- DAOs = Decentralized autonomous organizations
https://ethereum.org/ko/dao/#main-content
Member-owned communities without centralized leadership.
A safe way to collaborate with internet strangers.
A safe place to commit funds to a specific cause.
- NFTs =
Non-fungible tokens (NFT)
A way to represent anything unique as an Ethereum-based asset.
NFTs are giving more power to content creators than ever before.
Powered by smart contracts on the Ethereum blockchain.

# Your First Transaction
## MetaMask
디지털 지갑
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20224253.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20224330.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20224358.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20224446.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20224535.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20224733.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20224830.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230017.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230036.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230053.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230456.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230559.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230629.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230648.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20230820.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20231010.png)


>'비밀 복구 구문'이란 무엇인가요?
복구 구문은 지갑과 자금의 '마스터 키'입니다.
비밀 복구 구문은 어떻게 저장하나요?
비밀번호 관리자에 저장
은행 금고에 보관.
대여 금고에 보관.
적어서 여러 비밀 장소에 보관하세요.
비밀 복구 구문을 공유해야 하나요?
절대로, 누구와도, 심지어 MetaMask와도 비밀 구문을 공유하면 안 됩니다!
복구 구문을 요청하는 사람은 사기를 치려는 것입니다.

https://etherscan.io/
에 만들어진 월렛주소를 복사해서 붙여넣어 봅시다.

계정생성으로 추가 계정생성하기
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20231135.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20231824.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-27%20231933.png)
계정 옆에 더보기 버튼 -> 계정 상세보기 -> 계정 비밀키 내보내기 -> 트랜잭션에 필요한 private key를 얻을 수 있음

![계정세부정보](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20100603.png)

private key가 있다면 해당 계정에 접근가능하나. recovery phrase (12단어) 가 노출되는 경우 다른 계정까지도 접근가능
Public adrress는 etherscan등으로 다른사람도 조회가능 그러나 뱅킹을 하거나 할 수 없음

|Concept|Can Access|Private or Public|
|:---:|:---:|:---:|
|Mnemonic|All of your Accounts|Keep Private!|
|Private Key|1 of your account|Keep Private!|
|Public Address|Nothing|It's public|

### 네트워크 탭

![](Networktap%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20101648.png)
Ethereum Mainnet
현실의 돈이 사용되거나 소비되어 트랜잭션되는 메인 네트워크입니다.

여기서는 TestNet을 이용해서 테스트
TestNet 엔지니어용 테스트 넷입니다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20100603.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20102136.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20102205.png)
show/hide 클릭 -> Show test networks-> ON으로

테스트넷들은 fakemoney로 트레이드 합니다.
현재는 Rinkeby가 유명하고 그다음 Kovan을 많이 사용합니다.

때에 따라 좋은 테스트네트워크가 바뀔 수 있으니 git repository를 항상 확인해보시기 바랍니다.

여기서는 Rinkeby를 자주 사용할 겁니다.

검색창에 rinkeby etherscan을 입력하거나
rinkeby.etherscan.io로 접속합니다.
etherium explorer에 private address를 입력합니다.
트랜잭션이 없으므로 빈 정보가 뜰겁니다.

### 파우셋으로 테스트넷 이더리움 보내기
테스트하기 위해 이더리움을 충전해봅시다.

사용할 파우셋
https://faucets.chain.link/

백업파우셋
https://rinkebyfaucet.com/

먼저 링크비네트웍과 지갑을 연결해야합니다.
![체인링크파우셋에서 메타마스크연결](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20122045.png)

체인링크에서 링크비네트워크에 접속이 안되니 백업파우셋으로 보내보겠습니다.
![알케미파우셋](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20122923.png)

트랜잭션이 보입니다.

![지갑트랜잭션0.1](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20123243.png)

메타마스크 지갑에 0.1ETH가 들어왔습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20123345.png)

이더스캔에도 트랜잭션 목록이 추가되었습니다.

이 0.1ETH는 오직 Rinkeby Network에만 존재하며 
다른 테스트넷이나 이더리움 메인넷을 확인해보면 0ETH인것을 확인 할 수 있습니다.

체인링크 파우셋에서 보내기
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20124044.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20124120.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20124401.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20124454.png)

이더스캔에서 트랜잭션 정보를 클릭해서 살펴봅시다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20124842.png)

Transaction Hash:
블록체인을 구분하는 값입니다.
이 트랜잭션이 0.1ETH를 이 지갑에 보냈다는 자체를 나타내는 주소입니다.

Status:
트랜잭션 성공/실패 등 상태를 나타냅니다.

Block:
이 트랜잭션이 소속되어있는 블록을 보여줍니다.

TimeStamp:
트랜잭션이 일어난 시간을 나타냅니다.

From:
트랜잭션을 보낸 계정을 나타냅니다.
링크를 누르면 해당 계정을 확인 할 수 있습니다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20125505.png)

To:
트랜잭션을 받은 계정을 나타냅니다.
즉, 여기선 내 계정을 나타냅니다.

Value:
트랜잭션에 보내진 eth 값을 나타냅니다.

Transaction Fee:
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20125903.png)
트랜잭션 이용비용입니다.
즉, Gas를 나타냅니다.

### Gas 1: Gas 소개

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20132528.png)

### Transaction fee
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20132703.png)

블록체인은 모두 다른 각각의 노드에서 작동하고 있습니다.
이 각각의 노드에서 블록체인을 작동하기 위해 언제나 요금을 내고 있습니다.
트랜잭션이 발생할 경우 "miner" 나 "validators"가 소정의 수수료를 받습니다.
이 수수료가 사람들이 노드를 계속 구동할 수 있도록 해줍니다.

가스는 계산 측정 단위입니다.
복잡한 트랜잭션일수록 소비하는 가스도 많아집니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20135742.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20140139.png)
60의 가스 제한 중에 21의 가스를 사용했다는 의미입니다.
ETH 보내기와 같은 단순한 작업은 가격이 저렴하지만,
NFT를 발행하고, 몇몇의 나눠진 컨트렉트에 입금하는것과 같이 복잡한 작업에는 계산비용이 비싸고 비싼 값을 지불해야합니다.

GasPrice * Gas Usage by Txn = Transaction Fee
0.000000002500000009 * 21000 = 0.000052500000189

또한 블록체인마다 들어가는 계산하는 가스비용이 다릅니다.

모든 블록체인상의 트랜잭션에는 가스를 지불해야합니다.

### 내 지갑안에서 계정간 트랜잭션하기
Account1 에서 계정1로 0.05ETH를 보낼경우
Account1 에는 얼마가 남을까요

가스시세:
같은 시간에 트랜잭션을 보내는 사람이 많을수록 가스요금이 비싸집니다. 

내계정-> 활동 으로 확인해보면 트랜잭션이 pending상태로 되어있습니니다. 클릭하여 이더스캔으로 넘어가면 indexing이라고 나올텐데 그것은 이더스캔이 내 트랜잭션을 받고 정리하고 있는 중이라는 뜻입니다.
만약 트랜잭션이 제대로 이루어지지 않을 경우 다른 테스트넷을 사용하면 됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20160402.png)

트랜잭션이 success 되었다면 계정에 남은 ETH를 확인해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20160816.png)

ETH를 받은 계정은 정확히 0.05ETH를 가지고 있고, 보낸계정은 0.2ETH - (0.05 + Gas fee)의 ETH를 가지고있습니다. 

지금까지 테스트 해본방법이 어플리케이션을 이용해서 블록체인 프로토콜과 상호작용하는 방법입니다.

## How do Blockchains works?
Hashing, blocks, signers, etc...

https://andersbrownworth.com/blockchain/

### 해시

Hash:
데이터를 식별하기 위해, 고정된 길이의 고유한 값을 가지는 문자열입니다. 이러한 값은 해시함수에 의해 배치되고 생성됩니다.

Keccak256: 실제 이더리움이 사용하는 알고리즘

SHA 256: Keccak256 내에 포함된 크립토 알고리즘

https://andersbrownworth.com/blockchain/hash

### 블록

https://andersbrownworth.com/blockchain/block

블록은 블록넘버와 넌스 자료(데이터)를 모아 해시값을 생성하여 만들어집니다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20164424.png)

아무값이나 입력하고 채굴(mine)을 눌러봅시다.



![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20164639.png)

배경색이 초록색이 되었고(서명되었고) 넌스(nonce)값이 달라졌습니다. (72608 -> 60075)

해시값 또한 달라졌습니다. (0000으로 시작)

마이너(채굴가)들이 하는일이 바로 이 nonce값을 찾아내는 일입니다.
해당블록넘버 (#1)에서 nonce값이 0000으로 시작하는 해시값에 해당할때까지 bruteforce(일일히 대입)하여 Nonce 1~ 60075 까지 대입하여 알아내는 것입니다.
이렇게 하여 알아낸 0000으로 시작하는 해시값을 가진 블록을 서명된 블록이라고 합니다.

nonce 60075는 0000으로 시작하는 해시가 허용된 넌스입니다.

값을 입력한 뒤 붉은색으로 되는 블록은 해시값이 0000으로 시작하지 않고 서명되지 않은 블록입니다.
여기서 넌스값을 변경하여 0000로 시작하는 해시(즉, 서명된 블록)를 찾는겁니다. 이 과정은 brute force로 이루어집니다.

이것이 블록체인을 채굴혹은 채굴가들이 하는일입니다.

### 블록체인

https://andersbrownworth.com/blockchain/blockchain

위의 블록에 이전해시(prev)변수가 추가됩니다.

블록의 원조가 되는 해시값이 000000~ *64 인 블록은 
Genesis block이라 부르고 이것이 블록체인의 첫번째 블록입니다.

#### 불변성


블록체인 중 하나의 값을 바꾸게 되면 해시값이 달라지면서(0000으로 시작하지 않는 다른 값이 되기때문에, 해당 블록은 물론이고 다음 블록의 이전해시값도 유효하지 않게 됨) 다른 나머지 블록체인 또한 망가지게 됩니다.(다시 연겱하려면 모든 블록을 다시 채굴해야하기 때문에 시간과 비용이 많이 들어감)
이것이 불변성을 보장하는 방법입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20175643.png)

#### 분산 블록체인(Distribute Blockchain)

https://andersbrownworth.com/blockchain/distributed

마지막 해시는 모든 블록들과 연결되어있기때문에 블록들에게 영향을 끼칠 수 있습니다.

블록의 값이 바뀐다면 블록체인네트워크 안에 있는 참여자들(peer)이 모두 알아차릴 수 있으며 해당 사용자(peer)는 블록체인 네트워크에서 제외됩니다.(채굴로 서명을 받은 블록이라도 다른 peer의 블록 hash값과 일치하지 않기 때문에)

#### 토큰(Tokens)

https://andersbrownworth.com/blockchain/tokens

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20185113.png)

tx(트랜잭션)이 추가되었습니다.
매 트랜잭션마다 분산 네트워크를 가지고 있으며
트랜잭션 값을 바꾸면 마찬가지로 원래 참여하고 있던 블록체인 네트워크에서 제외됩니다.

Darcy 가 Bingley에게 돈을 보냈다는걸 어떻게 알 수 있을까요? 이 점은 private key와 public key를 통해 설명 할 수 있습니다.

### 정리

해시: 데이터를 식별하는 고유한 고정 길이 문자열입니다.

해시 알고리즘: 데이터를 고유한 해시로 계산하는 함수입니다.

마이닝(mining): 블록체인 "문제"에 대한 "해결책"을 찾는 과정입니다. 이 예에서 "문제"는 4개의 0으로 시작하는 해시를 찾는 것이었습니다. 노드는 마이닝 블록에 대한 비용을 받습니다.

블록: 함께 마이닝 된 트랜잭션 목록입니다.
(블록, 넌스, 트랜잭션, 이전해시, 해시)

분산화(Decentralized): 권한을 가지고 있는 단독지점이 없습니다.
(서로의 해시를 비교해서 트랜잭션이 정상적인지, 멜리셔스한지 판단) 

넌스(Nonce): 블록체인 문제에 대한 "해결책"을 찾기 위한 "한번 사용된 숫자(Number used once)"입니다.
또한 계정/주소의 트랜잭션 번호(Number)를 정의하기 위해 사용됩니다.

### Signing Transactions 트랜잭션 서명

>Darcy 가 Bingley에게 돈을 보냈다는걸 어떻게 알 수 있을까요? 이 점은 private key와 public key를 통해 설명 할 수 있습니다.

에서 이어지는 글입니다.

#### keys

https://andersbrownworth.com/blockchain/public-private-keys//keys

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20191949.png)

개인 키: 키 홀더에게만 알려져 있으며, 트랜잭션 "서명"에 사용됩니다.

private key를 입력하면 ECDSA(Elliptic Curve Digital Signature Algorithm) 에 의해 public key를 발급합니다.

#### Signatures
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20202930.png)


메시지에 값을 입력해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20204250.png)

여기에서도 ECDSA로 Private key를 바탕으로 Message Signautre가 발급됩니다.

Verify 탭으로 넘어가봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20204628.png)

Verify 버튼을 누르면 valid(배경초록색)이 되었습니다.

Signature에는 아까 전에 만든 Message Signature 값이 들어가 있습니다.

이 verify는 public key와 비교해서 verify 여부를 결정하고 아무나 verify 할 수 있습니다. 따라서 누구나 signature를 가지고 이 트랜잭션이 진짜인지 확인 할 수 있습니다.

#### Transaction 
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20205419.png)

20달러를 보내봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20205520.png)

마찬가지로 Private key 를 가지고 생성된 message signature를 가지고 signature 값과 비교해서 확인 할 수 있습니다.

이것이 private key를 숨겨야 하는 이유입니다.

Metamask의 setting > Security & Privacy 탭을 확인해봅시다.

reveal seed phrase 를 누르면 비밀번호 확인을 거쳐서 인증 12단어를 볼 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20210043.png)

비공개 키 내보내기

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20210207.png)

이런식으로 비공개 키를 내보낼 수 있습니다.

위에서 만든 Public Key는 Account1의 public key와 역할이 동일합니다.

### 정리

Public Key: Is derived from your private key. Anyone can "see" it, and use it to verify that a transaction came from you.

Public Key 공개키:
개인 키에서 파생되었습니다. 누구나 "확인"할 수 있으며, 사용자로부터 트랜잭션이 전송되었는지 확인하는 데 사용할 수 있습니다.

Signing a transaction: A "one way" process. Someone with a private key signs a transaction by their private key being hashed with their transaction data.
Anyone can then verify this new transaction hash with your public key.

트랜잭션 서명: "단방향" 프로세스입니다. 개인 키를 가진 사용자는 자신의 개인 키를 자신의 트랜잭션 데이터로 해시하여 트랜잭션에 서명합니다.
그러면 누구나 사용자의 공개 키로 이 새 트랜잭션 해시를 확인할 수 있습니다.

Private Key ||| barrier ||| > Public key > Address

## Gas 2: Block Rewards & EIP 1559

It's not important to understand everything in this section.

The main takeaway should be:
"The more people use a chain, the more expensive it is to send transactions"

21,000 | 21,000

트랜잭션에서 사용하고 싶은 가스량을 제한 할 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20221927.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20221944.png)

Base Fee: The minimum *gas price* to send your transaction

기본요금: 트랜잭션을 보낼 수 있는 최소 가스가격
Gwei가 뭘까요?

https://eth-converter.com

Wei Gwei Ether 가 있네요

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20223419.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-29%20223555.png)

1 Ether = 10,0000,0000 Gwei = 100,0000,0000,0000,0000 Wei

Max Fee: 사용할 수 있는 최대 가스량

Max Priority: 최대로 지불할 가스값 + 마이너에 줄 의향이 있는 최대 값
>https://www.blocknative.com/blog/eip-1559-fees
>
>우선 요금 설정
>
>최대 우선 순위 수수료(Max Priority Fee)는 종종 마이너 팁이라고도 하며, 당신의 거래를 블록에 포함시키기 위해 마이너에게 인센티브를 주기 위해 마이너에게 직접 지불되는 '선택적' 추가 수수료입니다. Max Priority Fee는 기술적으로 선택 사항이지만, 현재 대부분의 네트워크 참여자들은 포함 후보가 되기 위해 일반적으로 최소 2.0 GWE 팁이 필요하다고 추정한다. 이와 같이 특정 채굴 풀은 포함을 위한 대체 최소값을 설정할 수 있다.
>
>혼잡하지 않은 정상적인 네트워크 조건에서 제출되는 '일반적인' 트랜잭션의 경우, 최대 우선 수수료는 2.0 GWEI에 가까워야 합니다. 그러나 다음 블록에 순서나 포함이 중요한 트랜잭션이나 네트워크가 매우 혼잡할 경우 트랜잭션의 우선 순위를 정하기 위해 더 높은 최대 우선 수수료가 필요할 수 있습니다.
>
>Max Priority Fee에 대한 다소 미묘한 뉘앙스는 당신이 광부에게 기꺼이 지불할 수 있는 최대 팁을 나타낸다는 것이다. 단, 기본료+최대우선수수료가 최대수수료를 초과할 경우(아래 참조), 최대우선수수료의 상한을 유지하기 위해 최대우선수수료가 감소한다. 즉, 실제 팁은 최대 우선 수수료보다 작아야 할 수 있으며, 이러한 상황에서는 거래가 채굴자에게 덜 매력적일 수 있습니다.

Burnt = Base Fee * Gas Use

마이너에게 돌아가는 수익 = Transaction Fee - Burnt

Others:

Txn Type:2 (EIP-1559):
이 트랜잭션이 EIP-1559 타입의 트랜잭션이라는 뜻

많은 사람들이 트랜잭션을 이용할 수록
Burnt양이 늘어남

## EIP-1559
https://www.youtube.com/watch?v=MGemhK9t44Q

EIP(ETHEREUM IMPROVEMENT PROPOSAL)
트랜잭션의 변경된 기술사양을 다루는 문서입니다.
보통 기술사양 문서들은 기술적 세부사항을 개선하는데 중점을 둡니다.
그래서 개발자 커뮤니티에선 별로 다뤄지지 않습니다.

하지만 예외가 있는데 이것이 바로 EIP-1559입니다.
왜냐하면 지갑과 같은 사용자 어플리케이션에 관해서 큰 의미를 갖기 때문입니다.

eip1559는 이더리움 요금(fee)모델의의 변화를 설명하고 있으며 2019년에 비탈릭부테린(vitalik buterin)에 의해 제안되었습니다.

이더리움 요금 모델
First-price auction 첫 번째 가격 경매 라는 매커니즘을 기반으로 합니다.

the users who want to have their transaction picked up by a miner have to essentially bid for their space in a block
트랜잭션이 마이너에게 선택 받기를 원하는 사용자들은 기본적으로 그들의 블록 공간을 위해 입찰을 진행해야 합니다. 이는 사용자들이 특정 트랜잭션에 대해 기꺼이 지불할 의향이 있는 가스요금(gas price)을 제출해서 이루어집니다. 
마이너들은 이것을 가격이 높은 순으로 정렬해서 가장 수익성 있는 트랜잭션을 먼저 포함하여 거래를 선택합니다. 이는 매우 비효율적일 수 있고, 일반적으로 사용자가 거래에 대해 초과 지불하게 되는 결과를 초래하게됩니다.

이 모델또한 문제점이 있습니다.
metamask를 예로 들어보면 slow averge fast 중에 속도를 선택하여 또는 수동으로 가스가격을 조절할 수 있습니다.
일반적인 사용자들은 기본요금으로 트랜잭션이 confirm되기를 기다리는 상태가 되기도 전에 가스요금이 갑자기 급등해서 다시 요금 확인을 위해 기다리는 경험을 할 만큼 운이 좋지 않습니다. 이것은 물론 사용자 경험 관점에서도 좋지 않습니다. 

이것은 EIP-1559의 존재 이유기도 합니다.
제안서는 이 문제를 해결하기 위해 작성되었고 다음과 같은 목적을 가지고 있습니다.
- 트랜잭션 요금을 더 예측가능하게
- 트랜잭션 확인 딜레이를 줄이기
- 요금 입찰방식을 자동으로 하여 사용자 경험 향상
- 네트워크 활동과 ETH공급 사이에 긍정적인 피드백 루프 생성

### EIP-1559 FEE MODEL

- Base fee의 새 개념 : 
Basefee는 트랜잭션이 블록에 포함되기 위한 최소요금입니다.
- Base fee는 블록당 책정되며 이더리움 네트워크가 얼마나 혼잡한지에 따라 위아래로 조정이 가능합니다.

- Network Capacity 네트워크 용량 증설
가스 최대량을 12.5M에서 25M으로 늘림으로써, 네트워크 용량을 늘렸습니다.
기본적으로 블록사이즈가 두배로 늘었습니다.

- Base fee 와 네트워크 용량 증가로 EIP 1559 는  다음과 같은 로직으로 설계 될 수 있습니다.
  - 네트워크 사용량이 50% 이상일때 Base fee는 증가합니다.
  - 네트워크 사용량이 50% 이하일때 Base fee는 감소합니다.

이 말은 기본적으로 네트워크가 네트워크 사용량에 따라 수수료를 조정하여 50%의 용량에 평형을 맞추는 것을 목표로 한다는 것을 의미합니다.

### MINER TIP


 eip 1559 also introduces a minor tip a separate fee that can be paid directly to the miner to incentivize them to prioritize a transaction

 eip 1559는 또한 마이너팁을 도입하여 광부에게 직접 지불하여 거래의 우선순위를 부여하도록 장려할 수 있습니다.

 이것은 마이너들이 높은 가스금액에서 인센티브를 받을 수 있는 현재 매커니즘과 비슷합니다. 

이는 (arbitrage transactions)차익거래 같은 트랜잭션과 같은 빠른 트랜잭션 confirm으로 이익을 얻을 수 있을때 있어서 매우 중요한 기능입니다. 

### EIP 1559 와 기존 모델 비교
#### 기존 네트워크 모델
imagine the minimum gas fee to be included in the previous block was 50 gray the network activity seems to remain the same. so users start submitting their transactions with 50 gray trying to be included in the next block

블록에 포함되기 위한 최소가스 수수료가 50Gwei라고 가정해봅시다. 네트워크 활동은 동일하게 유지되므로 사용자는 다음 블록에 포함하려고 하는 50Gwei로 트랜잭션을 제출하기 시작합니다. 동시에 매우 기대되는 토큰이 출시되어 이를 사고싶어 하는 사용자들이 현재 입찰가를 크게 높였습니다. 이제 다음 블록에 포함될 수 있는 최소금액은 100Gwei 입니다.
만약 네트워크 활동이 여러 후속 블록에서도 여전히 혼잡하다면 이미 트랜잭션 요금으로 50Gwei를 낸 사용자는 매우 긴 시간동안 트랜잭션 확인을 기다려야 합니다.
이 경우 블록 사이즈는 12.5백만 가스로 제한되며 블록에 들어갈 수 있는 유일한 방법은 다른 사용자보다 더 높게 입찰하는 것입니다.

#### EIP 1559 의 경우
같은 상황에서 EIP 1559는 이렇게 작동합니다.
이전 블록에서 다음블록으로 옮기는데 50Gwei 가 최소요금으로 설정된 블록에 네트워크 사용률은 50%였으며 대부분의 블록은 최대 가스 제한의 절반인 1250만 가스를 사용했습니다.
새 토큰 출시로 인한 요금 급등은 사용자들이 더 높은 마이너 팁으로 거래를 하게 만듭니다.
블록 공간에 대한 높은 수요와 높은 마이너 팁을 가진 많은 트랜잭션을 볼때 마이너가 2500만 가스의 최대 상한선인 블록을 생성합니다. 더 많은 트랜잭션이 블록에 포함 될 수 있지만, 또한 후속 블록의 base fee 가격이 증가하게 됩니다.

현재 블록이 100% 꽉 찼고, 여전히 네트워크 활동량이 높고, 블록공간에 대한 수요가 높게 유지된다면, 마이너들은 각각의 후속 블록에 기본료를 증가시키면서 꽉 찬 블록을 계속 생산할 것입니다.

어느 시점에서는 요금이 일부 사용자들을 쫓아낼 만큼 충분히 높아져서, 네트워크가 다시 50% 이하의 네트워크 이용률로 돌아오기 시작하고 후속 블록에서 요금을 낮추기 시작할 것입니다. 기본요금은 블록당 최대 12.5퍼센트까지 오르내릴 수 있기 때문에 기름값은 5분 정도 20블럭에서 10배, 40블럭에서 100배까지 소요된다.

...계속

### 정리

Txn Savings : Max값과 실제 지불한 값의 차이

## High-Level Blockchain Fundamentals
블록체인 Peer마다 가지고 있는 Node에서 작동합니다.
네트워크는 참여자가 모여서 이루어집니다.

Node: A single instance in a decentralized network
노드 : 분산 네트워크의 단일 인스턴스

모든 사람이 네트워크에 참가할 수 있습니다.

Blockchains are resilient

블록체인은 복원력이 뛰어납니다. (다른 노드가 다운되더라도 작동할 수 있습니다)
또한 다른 노드가 멜리셔스하다면 그 노드를 제외합니다.

Blockchain nodes keep lists of the transactions that occur.
블록체인 노드는 발생하는 트랜잭션 목록을 보관합니다.
이것이 블록체인에 불변성을 더해줍니다. 아무것도 부패하지 않고, 변하지 않습니다.

### Consensus 컨센서스
#### proof of work
우리가 전에 살펴본 마이닝 기능을 proof of work 이라고 합니다.

proof of work(작업증명)과 proof of stake(이해관계증명)는 컨센셔스의 아래에 놓여있습니다.

컨센서스(합의)는 블록체인의 상태나 하나의 값에 동의하는데 사용되는 메커니즘입니다. 

컨센서스 프로토콜을 크게 나눠보자면 두개로 나눌 수 있습니다.
1. Chain Selection algorithm
2. Sybil Resistance mechanism -> 마이닝 사용(proof of work) 이더리움, 비트코인

http://wiki.hash.kr/index.php/%EC%8B%9C%EB%B9%8C%EA%B3%B5%EA%B2%A9#:~:text=%EC%8B%9C%EB%B9%8C%EA%B3%B5%EA%B2%A9(sybil%20attack)%EC%9D%B4%EB%9E%80,%EC%9D%84%20%EB%AF%B8%EC%B9%98%EB%8A%94%20%EA%B3%B5%EA%B2%A9%EC%9D%84%20%EB%A7%90%ED%95%9C%EB%8B%A4.

시빌 저항이란 시빌공격(공격자가 실제로는 한명이면서 마치 여러 명인 것처럼 속이는 방식으로 네트워크 상 여러 노드를 제어함으로서 의사결정에 좋지 않은 영향을 미치는 공격)으로부터 방어하는 블록체인의 능력을 뜻합니다.

시빌 저항에는 PoW 와 PoS 두가지 매커니즘이 있습니다.

PoW 작업증명:
블록체인 문제를 해결하여 증명 (앞서 실습해본 0000으로 시작하는 nonce를 찾기 같은)

no matter how many sudo anonymous account to make, each one still has undergo to very computationally expensive activity finding the answer to the proof of work problem.

얼마나 많은 sudo 익명 계정을 만들든지 간에, 각각의 계정들은 여전히 작업 증명 문제에 대한 답을 찾는 계산적으로 매우 비싼 활동을 겪습니다.

어떤 블록체인들은 알고리즘을 어렵게 만들거나 쉽게 만드는데 이는 블록타임을 조절하기 위함입니다.

블록타임 - 블록이 발행되는데 걸리는 시간, 알고리즘이 얼마나 어려운지에 비례합니다.

#### chain selection rule
이제 컨센서스를 생성하기 위해선 
시빌 저항을 chain selection rule과 합성해야 합니다.

우리가 어떻게 어떤 블록체인이 진짜 블록체인인지 알 수 있을까요? 

#### 나카모토 컨센서스
나카모토 컨센서스는 pow 와 가장 긴chain rule을 결합한 컨센서스입니다.


#### Block Confirmations
트랜잭션이 끝난 후 남은 블록들

This has recently changed as of EIP 1559
최근에 나카모토 컨센서스는 EIP 1559로 바뀌었습니다.

Pow(작업증명) -> 채굴자Miner
Proof of Stake -> Validater 검증인

작업증명에서는 모든 노드가 블록체인 문제를 해결하기 위해 경쟁합니다. 모든 노드가 이 "퍼즐"을 제일 "먼저" 해결하기 위해 노력합니다. 왜냐하면 첫번째로 문제를 푼 노드가 트랜잭션 fee를 얻을 수 있기 때문입니다.

노드는 두가지 방식으로 보상을 받을 수 있습니다.
하나는 트랜잭션 요금이고
다른 하나는 block award 입니다.
블록어워드는 블록 체인 자체에서 프로토콜로부터 이 노드에 주어집니다.

- 비트코인의 블록 반감기 (block halving)
블록이 대략 50%로 줄어드는것
https://academy.binance.com/ko/halving

블록어워드를 더이상 못얻게 하는 블록체인도 있습니다.

- sybil 공격
- 51% 공격 이더리움 클래식에서 일언난 공격


Longest chain rule:
블록체인의 규모가 클수록 안전하다

Proof of Stake
pos에서는 miner대신 validater 검증인 이라고 합니다.
pow는 너무 많은 에너지가 들어갑니다. 환경문제

ETH 2.0 으로 업그레이드 하면서 POS로 변화했습니다.

Proof of stake nodes put up collateral as a sybil resistance mechanism
Pos 노드는 담보물이 sybil 저항 매커니즘으로 설정되어있습니다.
이 담보물이 stake입니다.

ETH2.0을 예로들면 노드는 ETH를 stake로 삼아 정직하게 활동하도록 합니다. 만약 노드가 악의적 행동을 한다면 그들은 stake를 줄이거나 제거할 것입니다.

이는 효과적인 시빌 저항 매커니즘입니다.
만약 익명의 여러 계정을 만든다면 각각의 노드마다 stake를 가져야 할것입니다. 이 상태에서 잘못된 행동을 한다면 여러 계정을 만드는데 담보로 잡힌 stake(ETH)들을 모두 잃게 될 겁니다.

이 시스템 상에서 채굴자(miner)들은 검증인(validator)이라 불립니다.

- Randomness

Proof of stake uses much less energy
하나의 노드만 문제를 풀고 나머지는 검증만 하면 되기 때문

- Scalability
많은 사람들이 블록체인을 원할때 가스값이 올라갈것이다
이것은 스케일러블에 나쁨
- Sharding : scalability 문제를 해결하기 위한 솔루션
블록체인안의 블록체인

- Layer1: Base layer blockchain implementation

- Layer2: Any appplication built on top of layer2
layer1 위에 구현되어있는 모든 어플리케이션들

아베트롬 옵티미즘 -> Rollups
샤드 체인지 해주는것
싸이체인과 다름 싸인은 자신의 프로토콜로 보안
Rollups -> 베이스레이어로 보안

## Recap
ETH and BTC are Proof of Wrok (at the time of recording)

- ETH 2.0 will be Proof of Stake
- Pow & Pos are sybil resistance mechanisms
- The bigger the blockchain, the more secure
- Sharding and rollups are scalability solutions
- Only so many transactions can fit into a block
- Gas prices are how much it costs to perform executions on-chain

# Welcome to Remix!

## 리믹스 시작하기
https://remix.ethereum.org/

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20172203.png)

Solidity 선택

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20172254.png)


![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20172407.png)

처음부터 시작해보기

contracts폴더만 남겨놓고 안의 내용과 나머지들을 다 지워봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20172753.png)

contracts 폴더에 SimpleStorage.sol 파일을 만듭니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20173011.png)

.sol 파일은 컴파일러가 solidity 파일로 인식하며 solidity는 스마트 계약 부분에서 가장 점유율 높은 언어입니다.

### 솔리디티 컴파일러 탭

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20173439.png)

첫번째로 해야할 일은 어떤 버전의 솔리디티를 사용할 것인지 정하는 것입니다.

이 부분은 항상 솔리디티 코드의 제일 위쪽 줄에 위치해야 합니다.

솔리디티는 지속적으로 업데이트 되는 언어입니다.
따라서 업데이트 되는 최신 버전의 솔리디티를 쓰고 싶다면
이렇게 입력하면 됩니다.

```solidty
pragma solidity
```

특정 버전을 사용하고 싶다면 뒷부분에 버전을 입력하면 됩니다.
```
pragma solidity 0.8.7; // 0.8.12
```
주석은 // 로 처리합니다.

현재 최신버전은 0.8.12 (2022-06-01기준)입니다.
스테이블 버전은 0.8.7 이기때문에 0.8.7 버전을 사용할 겁니다.

코드를 배울때 항상 주석으로 노트합시다. 복습에 도움이 됩니다.

만약 표기버전보다 더 높은 버전을 사용해도 괜찮다는 표시를 하고 싶을땐 `^`를 붙여서 입력하면 됩니다.
```
pragma solidity ^0.8.7;
```
아니면 특정 버전 범위를 정해서 해당 버전의 컴파일러만 작동하도록 만들 수도 있습니다.
```solidity
pragma solidity >=0.8.7 <0.9.0; //0.8.7이상 0.9.0 미만의 컴파일러만 작동
```

또한 모든 솔리디티 코드는 `;`로 끝나야합니다.

### SPDX License Identifier
  - 라이센스 관리와 코드 공유에 도움이 됩니다.
  - 이는 옵션 선택이지만 가끔 이를 요구하는 컴파일러가 있습니다.
  - 이 설정은 컴파일러 설정보다 먼저(코드 위쪽에) 위치해야합니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;
```

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20175739.png)

이제 왼쪽 탭에 있는 Complie SimpleSotrage.sol 버튼을 눌러봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20175918.png)

컴파일러가 0.8.8 로 자동으로 바뀌었습니다.

`ctrl + s` 를 눌러 `저장 후 컴파일`이 가능합니다.

코드안에서 0.8.8로 설정 후 다른 버전의 컴파일러를 선택해서 컴파일 할 경우 자동으로 0.8.8버전이 설정되지만, ^0.8.8 과 같이 허용범위를 설정해놓았다면 다른 버전의 컴파일러를 선택하면 그 버전의 컴파일러로 컴파일됩니다.

### contract

contract 키워드는 contract를 정의하는 키워드입니다.
java나 javascript같은 객체지향형 프로그래밍 언어의 class와 비슷하다고 보면 됩니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;

contract
```

`{}` 열어 SimpleStorage 안의 내용을 작성할 수 있습니다.
```
contract SimpleStorage {
    
}
```

`ctrl s`를 눌러 저장 후 컴파일 해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20181558.png)

이번에는 모두 에러메세지 없이 모두 초록색 체크표시가 뜨는 걸 볼 수 있습니다.

이 초록색 표시는 코드가 정상적으로 컴파일 됐으며, 에러가 없다는 뜻입니다.

we get hypothetically deploy this contract right now and it would be a valid contract.
현시점에서 이 계약을 배포한다고 가정한다면, 이 계약은 유효할 것입니다.
축하합니다. 당신의 첫 계약을 작성해봤어요.

## Basic Solidity Types

솔리디티는 많은 타입과 원시자료형(원시자료타입)을 가지고 있습니다.

솔리디티 공식문서를 보면 더 자세히 알 수 있습니다.

https://docs.soliditylang.org/en/v0.8.14/types.html

https://solidity-kr.readthedocs.io/ko/latest/types.html

기본적인 타입들은 다음과 같은 것들이 있습니다.

boolean: 참 ,거짓

uint: unsigned int , 양의 정수

int: integer, 정수

address: 주소, 메타마스크 계정에 있는 그 주소가 맞습니다.

bytes: 로우레벨에서 사용할 수 있는 단위 나중에 더 자세히 다룹니다.

hasFavoriteNumber 라는 변수를 만들어볼까요. 
```solidity
contract SimpleStorage {
    // boolean, unit, int, address, bytes
    bool hasFavoriteNumber = true;
    uint256 favoriteNumber = 123;
    string favoriteNumberInText = "Five";
    int256 favoriteInt = -5;
    address myAddress = 0xC2a354ac356d3c4BC00432A4989C5fD7a6c4e199;
    bytes32 favoriteBytes = "cat"; // bytes 오브젝트는 자동으로 들어온 자료값을 bytes로변환합니다. ex) 0x12345215asdfa...
    // bytes는 bytes1, bytes2 가 가능하고 32가 최대값입니다. 
    // uint 와 int는 8의 제곱으로 설정해야 합니다. uint8 uint16 uint32
}
```

디폴트 벨류

```
contract SimpleStorage {
    uint256 favoriteNumber; 
    // unit256 favoriteNumber = 0; 과 같습니다.
    // 0으로 초기화됩니다.
}
```

### Basic Solidity Functions

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;

contract SimpleStorage {
    // 이 변수는 0으로 초기화 됩니다.
    uint256 favoriteNumber;

    //함수도 다른 언어와 마찬가지로 사용됩니다.
    // 이 함수는 uint256 형태의 인수를 가지는데 이름은 _favoriteNumber 입니다.
    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
    }
}
```

이쯤에서 테스트넷에 배포를 해봅시다.

https://remix-ide.readthedocs.io/en/latest/run.html#run-setup


`Save and Compile` 후에 `Deploy & run transactions` 탭으로 넘어갑니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20195540.png)

ENVIRONMENT 에 있는 VM 들은 가상머신(VM)에서 작동하는 fake블록체인입니다.
테스트넷에 직접 접근하지 않아도 이곳에서 JavaScript VM를 통해 테스트를 할 수 있습니다.

ACCOUNT 에는 100ETH가 들어있는 가상 계좌들이 담겨있습니다.

현재 CONTRACT는 SimpleSotre 하나만 작성했기때문에 SimpleStore로 설정되어있습니다.

이제 DEPOLY를 눌러봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20195918.png)

아래쪽 탭을 눌러보면 `SIMPLESTORAGE`가 `0xd9145CCE52D386f254917e481eB44e9943F39138`에 배포되었습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20201156.png)

주황색 버튼에는 전에 작성한 `store` 함수가 이름으로 들어가 있고 그 옆의 인풋에는 함수 파라미터인 `uint256 _favoriteNumber` 를 볼 수 있습니다.

이처럼 스마트 컨트렉트는 지갑계정과 마찬가지로 주소를 갖습니다.

COPY를 눌러 복사해봅시다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20201546.png)

콘솔창에서 트랜잭션 정보도 확인 할 수 있습니다.
Etherscan에서 확인한 정보와 비슷하죠?
이는 VM에서 시뮬레이션한 트랜잭션입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20201822.png)

새 계약을 만들어 포함시키는 일과 같이 온체인(on-chain)에서의 변화를 주는 일은 항상 트랜잭션을 발생시킵니다. 

이제 store 버튼을 작동시켜볼까요
인수 _favoriteNumber 에 적당한 숫자를 넣고 store 버튼을 눌러 함수를 작동시켜봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20203050.png)

계좌를 확인해보면 소량의 ETH가 소진되어 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20203157.png)

이 store 함수를 실행시키기 위해 transction이 발생해 gas요금으로 나간것 입니다. 

한번 더 해봅시다.
이번엔 5를 store 해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20203547.png)

역시나 트랜잭션이 발생합니다.

여기서 우리의 favoriteNumber는 어떻게 볼 수 있을까요?
현재 uint256 favoriteNumber는 private이기 때문에 확인 할 수 없습니다. 이에 관해서(visibility) 나중에 다뤄 볼 겁니다.

현재는 `uint256 public favoriteNumber;`로 바꾸면 public으로 접근이 가능합니다.

다시 컴파일 후에 배포해봅시다.

먼저 컴파일을 한 후 배포탭에 가서 Deploy Contracts 에 있는 배포된 계약을 x버튼을 눌러 삭제합니다.
- 이 버튼은 리스트 상에서만 삭제하는것이고 사실 실제 블록체인환경에서는 사라지진 않습니다. 블록체인은 불변하니까요. 하지만 이곳은 테스트용 가상블록체인이기 때문에 명목상 삭제하는셈 치는겁니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20205247.png)

그런 다음 다시 Deploy 합니다.

store 밑에 추가로 favoriteNumber 버튼이 나타났습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20205521.png)

이 버튼은 public favoriteNumber를 대표하는 버튼입니다.

이 상태에서 누르면 어떻게 될까요?
0으로 초기화 된 값이 보입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20210034.png)

`0: uint256: 0`
이 타입은 uint256이고 값은 0이라는 뜻입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20210057.png)

이번엔 5를 넣고 store 눌러 저장한 다음
다시 favoriteNumber를 호출해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20210313.png)

값이 5로 업데이트 된 걸 확인 할 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20210403.png)


### visibility

https://docs.soliditylang.org/en/v0.8.14/cheatsheet.html?highlight=visibility#function-visibility-specifiers

>```solidity
>function myFunction() <visibility specifier> >returns (bool) {
>    return true;
>}
>```
>public: visible externally and internally (creates a getter function for storage/state variables)
>
>private: only visible in the current contract
>
>external: only visible externally (only for functions) - i.e. can only be message-called (via this.func)
>
>internal: only visible internally

- public: 외부적으로 볼수 있고 내부적으로도 볼 수 있습니다. (스토리지/상태 변수들의 getter 함수를 만듭니다.)
이말은 이 계약과 상호작용하거나 볼 수 있는 아무나 이 변수나 함수를 호출 할 수 있습니다.
또한 public 변수에는 가지고 있는 값을 반환(return)하는 함수(getter)가 구현되어있습니다. 이런 이유로 파란 favoriteNumber 버튼을 누르면 반환된 값을 볼 수 있는겁니다.

- private: 오직 이 계약 안에서만 볼 수 있습니다.
private은 오직 이 특정한 계약 안에서만 호출 할 수 있는 함수를 뜻합니다.

- external: 오직 외부에서만 볼 수 있습니다(오직 함수를 위해 사용할 수 있습니다) this.func 을 통해서만 호출 할 수 있습니다.
external은 외부의 누군가가 이 계약안의 함수를 호출 할 수 있습니다.

- internal: 내부적으로만 보입니다.
internal은 이 계약에서 그리고 그 자식요소들만이 이 함수를 호출 할 수 있습니다.

참고로 visibility의 디폴트값은 internal입니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;

contract SimpleStorage {
    // 이 변수는 0으로 초기화 됩니다.
    // 여기서 visibility를 따로 설정해 놓지 않으면 기본 internal입니다.
    uint256 public favoriteNumber;

    //함수도 다른 언어와 마찬가지로 사용됩니다.
    // 이 함수는 uint256 형태의 인수를 가지는데 이름은 _favoriteNumber 입니다.
    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
    }
}

//0xd9145CCE52D386f254917e481eB44e9943F39138
```

- _favoriteNumber 앞의 `_`는 favortieNumber와 구분해 주기 위해 붙인겁니다. 파라미터를 위한 더 좋은 이름은 무엇인가 같은 네이밍 컨벤션에 관한 이야기를 나중에 다뤄볼 것입니다.

블록체인의 상태를 바꾸는 모든 일은 반드시 트랜잭션을 수반한다는 사실을 기억하세요.

리믹스 콘솔의 트랜잭션을 확인해 보면 이더리움을 보낼때(21000가스)보다 훨씬 더 많은 가스가 소비된다는 사실을 알 수 있습니다.

이는 단순히 이더리움을 주고받는 것보다 더욱 복잡한 값을 주고받기 때문입니다.(store함수와 favorteNumber 같은)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20213543.png)

### A quick gas example

만약 store 함수 안에서 더 많은 일을 처리한다면 어떻게 될까요?

값을 1 더해서 업데이트 해주는 기능을 추가해 봅시다.

```solidity
    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
        favortieNumber = favoriteNumber + 1;
    }
```
다시 컴파일 후에 배포된 계약리스트를 삭제한 후 재배포합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20214157.png)

다시 아무값이나 store를 해봅시다.

리믹스 로그에서 가스값을 확인해 보면 약 1.7배 가까이 가스소모가 늘어난 것을 확인 할 수 있습니다.
(26624 -> 44132)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20214328.png)

이처럼 함수안에서 무언가 더 많이 할 수록 소모되는 가스가 많아집니다.

### Scope

`favoriteNumber`는 global 스코프에 위치해있습니다.
이 말은 SimpleStorage의 {} 안에 있는 어떤 것이든 `favoriteNumber`에 접근할 수 있다는 뜻입니다.

만약 이런경우는 어떨까요?
something 함수에서 store 함수에서 선언한 testVar에 재할당 하고 있습니다. 가능할까요?

```solidity
contract SimpleStorage {

    uint256 public favoriteNumber;

    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
        uint256 testVar = 5;
    }

    function something() public {
        testVar = 6;
    }
}
```

store 의 {} 안에서 선언된 testVar 는 그 안에서만 접근이 가능합니다. 그러므로 something() 함수안의 testVar는 testVar를 찾지 못하고 에러가 발생하게 됩니다.

`uint 256 public favoriteNumber;` 가 값을 반환하는 게터함수를 가진다는 사실을 알고 있습니다. 이 함수를 수동으로 구현해볼까요

```solidity
contract SimpleStorage {

    uint256 public favoriteNumber;

    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
        uint256 testVar = 5;
    }

    function retrieve() public view returns(uint256) {
        return favoriteNumber;
    }
}
```

컴파일 후 재배포 해봅시다.

retrieve 버튼이 보입니다.
store에 값을 넣은 뒤 눌러보면
favoriteNumber와 같은 역할을 하고 있다는걸 알 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20220319.png)

그런데 함수로 구현된 retrieve도 파란색 버튼이 되어있습니다.
그렇다면 여기서 주황색 버튼과 파란색 버튼의 차이는 뭘까요?

이유는 바로 `view` 키워드 때문입니다.
```solidity
function retrieve() public view returns(uint256) {
        return favoriteNumber;
    }
```

**`view`와 `pure` 이 두가지 키워드를 가진 함수들은 단독으로 호출되었을 때, 가스를 전혀 소모하지 않습니다.**

`view` 키워드는 이 계약안의 상태(state)를 읽기만 하겠다는 뜻입니다.

대신 `view`와 `pure` 함수는 상태를 변경할 수 없습니다.

여기에 더해서 `pure` 함수들은 블록체인의 상태를 읽는것도 허락해 주지 않습니다. 

puer function의 예
```
    //view ,pure 단독 호출시 가스를 소모하지 않는 함수들
    function retrieve() public view returns(uint256) {
        return favoriteNumber;
    }

    function add() public pure return(uint256) {
        return (1 + 1);
    }
```

수학적인 계산을 하는 함수나, 다른 값들을 읽기위한 알고리즘을 만드는 함수를 만드는 공간으로 사용할 수 있습니다.

이처럼 view, pure 와 같이 값을 읽거나 state를 변경하지 않는 함수는 gas를 소모하지 않습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20222000.png)

view와 pure 함수를 작동시켰을때 로그입니다.
보시다시피 트랜잭션로그와 달리 가스소모가 없습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20222336.png)

한가지 더 알아둬야 할 게 있습니다.

execution cost 라는 것이 보입니다.
23479 gas 가 소모된다고 되어있는데, 이는 가스가 소모되는 함수(gas calling function)에서 view나 pure 함수를 호출하게 되면 그때 발생하는 가스 비용입니다.
따라서 view, pure 함수는 평소에는 가스를 소비하지 않지만 가스를 소모하는 함수에서 호출을 받으면 excution cost 만큼 가스를 소모하게 됩니다.

기억하세요. 블록체인 state를 변경할때 트랜잭션이 일어나고, gas를 소모하게 됩니다.

```
function store(uint256 _favoriteNumber) public {
    favoriteNumber = _favoriteNumber;
    retrieve();
}
```

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20222932.png)

```
function store(uint256 _favoriteNumber) public {
    favoriteNumber = _favoriteNumber;
}
```
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20223128.png)

소량의 가스가 좀 더 소모된걸 확인 할 수 있습니다.
근데 excution cost만큼은 아니네요.

`returns` 키워드는 이 함수가 어떤 값을 반환해아 하는지를 알려줍니다. 여기서 store에 `5`를 넣고 실행했다면 uint256 타입의 값 `5`를 받아 볼 수 있습니다.

### Basic Solidity Arrays & Structs

#### Struct
favoriteNumber에 많은 양의 다른 수들을 저장하는 방법이 있을까요?

우리는 여기서 새 타입을 `sturct`라는 키워드를 통해 만들 수 있습니다.
`많은 사람들의 좋아하는 숫자를 가진` `People`이라는 타입을 만들어 봅시다.

```solidity
    struct People {
        uint256 favoriteNumber;
        string name;
    }
```
자 이제 People 타입을 사용할 수 있습니다.
People은 uint256 타입의 favortieNumber를 가지고있고, name이라는 문자열을 가지고 있습니다. 

이제 People 타입을 사용해봅시다.
uint public favoriteNumber;와 비슷하게 사용할 수 있습니다.

```solidity
uint256 public favoriteNumber;
People public person = People({favoriteNumber: 2, name: "Kim"})

struct People {
    uint256 favoriteNumber;
    string name;
}
```

컴파일 후 재배포를 해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20224736.png)

person이라는 새 버튼이 생겼습니다.
눌러보시면 person이 가지고 있는 People타입의 객체를 받아볼 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20224900.png)

여기서 맨 왼쪽에 있는 0,1 숫자는 변수의 index를 나타냅니다.

참고로 uint256 public 변수를 서로 다른 이름으로 선언한다면,
이것들도 index를 차례로 가지게 됩니다.

이 이유에 대해선 나중에 더 알아보도록 합시다.

```solidity
    uint256 public favoriteNumber;      --- 0
    uint256 public favoriteNumberOne;   --- 1
    uint256 public favoriteNumberTwo;   --- 2
```

#### Array

더 많은 사람들을 만들고 싶은데, 이렇게 만들어야 할까요?

```solidity
People public person = People({favoriteNumber: 2, name: "Kim"});
People public person1 = People({favoriteNumber: 5, name: "CHAD"});
People public person2 = People({favoriteNumber: 7, name: "pepe"});
```
한두명이면 몰라도 100명 쯤 된다면 정말 힘들겁니다.

이런 목록을 만드는데 더 나은 방법이 있습니다.
바로 자료구조의 한가지인 Array를 이용하는 겁니다.

배열(Array)는 서로 다른 타입들을 가진 목록을 가진 자료구조입니다.

전통적으로 이런식으로 변수를 선언했다면
```
객체타입    객체visbility  변수이름;
uint256    public         favoriteNumber;
```

배열 또한 같은 방법으로 선언하면 됩니다.
```
// People타입을 가진 배열([])타입
People[] public people
// uint256타입을 가진 배열([])타입
uint256[] public favoriteNumbersList
```

컨트랙트에 people배열을 만든 뒤 재배포 해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20231124.png)

people 버튼이 보입니다.

그런데 다른 getter와 달리 uint256 타입의 값을 입력 할 수 있는 인풋을 가지고 있습니다.

uint256 값에 아무 숫자나 넣어봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20231323.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20231341.png)

0,1 을 넣어도 아무것도 반환하지 않습니다.

왜냐하면 지금 people 배열이 비어있기 때문입니다.

또한 여기에 들어가는 uint256 값은 바로 배열의 index 값을 뜻합니다.

### Dynamic Array vs Fixed-Sized Array

`People[]` 같은 배열타입을 Dynamic Array 라고 부릅니다.

왜냐하면 배열의 사이즈를 정해주지 않았기 때문인데요,

만약 `People[3]` 이렇게 작성한다면
People을 타입으로 갖는 array는 최대 3개의 요소만 가질 수 있습니다. (Fixed-Sized Array)

`People[]`는 어떤 사이즈든 가능합니다.
여기선 Dynamic Array를 사용할 겁니다. 임의의 수(arbitrary number)를 받아야 하기 때문이죠.

비어있는 `people` 배열을 채워줄 수 있는 addPerson 함수를 만들어 봅시다.

```solidity
function addPerson(string memory _name, uint256 _favoriteNumber) public {
    people.push(People(_favoriteNumber, _name));
}
```
Array.push 메소드를 이용해 어떤 요소를 넣을것인데,
그 요소는 바로 struct People({})로 만들어진 객체입니다. People 안에 들어갈 값은 인수로 받아온 _favoriteNumber, _name 입니다.

이는 다른 방식으로 표현할 수 있습니다.

```solidity
function addPerson(string memory _name, uint256 _favoriteNumber) public {
    // people.push(People(_favoriteNumber, _name));
    People newPerson = People({favoriteNumber: _favoriteNumber, name: _name});
    people.push(newPerson);
}
```
`People newPerson = People({favoriteNumber: _favoriteNumber, name: _name});`
이 방법은 위에서 하나씩 People 배열안의 리스트를 만들 때 사용하던 방법입니다. 이를 함수에서 받는 인수를 이용하여 newPerson이라는 임시 리스트를 만든 뒤
이를 people 배열에 push 하도록 만들었습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20233541.png)
컴파일을 해보면 다음과 같은 에러가 나타납니다.

`People memory newPerson`으로 고치면 해결됩니다.

memory 키워드에 대해선 나중에 좀 더 알아봅시다.
(Basic memory 편으로)

```solidity
function addPerson(string memory _name, uint256 _favoriteNumber) public {
    // people.push(People(_favoriteNumber, _name));
    People newPerson = People({favoriteNumber: _favoriteNumber, name: _name});
    people.push(newPerson);
}
```

이제 컴파일 후 다시 배포해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20234059.png)

people 에 0을 넣으면 역시 아무 값도 반환하지 않습니다.

addPerson에 People 타입의 형식에 맞게 값을 넣은 뒤 호출해 봅시다. 

참고로 알맞지 않은 타입의 값을 넣게 되면 다음과 같은 에러가 로그에 나타납니다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20234316.png)

Kim, 7을 넣고 addPerson을 누른 후

people 에 0을 넣고 호출해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20234413.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20234613.png)

입력한 값들이 people index에 알맞게 호출되는걸 확인 할 수 있습니다.

코드를 좀 더 줄여보면 이렇게도 사용가능합니다.

```solidity
function addPerson(string memory _name, uint256 _favoriteNumber) public {
    // people.push(People(_favoriteNumber, _name));
    // People memory newPerson = People({favoriteNumber: _favoriteNumber, name: _name});
    People memory newPerson = People(_favoriteNumber, _name);
    people.push(newPerson);
}
```

### Basic Solidity Erros & Warnings

붉은색 에러 -> 컴파일 에러 (ex:세미콜론 누락)

노란색 에러 -> 경고 (ex: SPDX-License-Identifier 나 사용하지 않는 선언된 변수 등)
경고는 코드실행을 막지 않습니다. 

### Basic Solidity Memory, Storage, & Calldata (Intro)

```solidity
function addPerson(string memory _name, number _favoriteNumber) public {
    people.push(People(_name, _favoriteNumber));
}
```
이 코드에서 memory 키워드를 삭제하면 에러가 발생합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-01%20233541.png)


#### EVM Overview (Data Location)

솔리디티에서 EVM이 정보를 저장하고 접근할 수 있는 곳은 6군데가 있습니다.

- EVM can access and store information in six places: 

1. Stack
2. Memory
3. Storage
4. Calldata
5. Code
6. Logs

지금 당장은 모든걸 다루지 않고 제일 중요한 3가지만 다뤄보겠습니다.

-> calldata, memory, storage

calldata 와 memory는 오직 임시적으로만(temporary) 존재하는 변수입니다.

즉 위 코드에서 _name 변수는 addPerson 함수가 호출되어서 트랜잭션이 발생할때만 존재합니다.

storage 변수는 함수가 실행된 후 함수 바깥에서도 존재하는 함수입니다.

예를 들어 `uint256 favoriteNumber;`는 storage 키워드를 사용하지 않아도 storage변수로 존재하고 있습니다.

calldata vs memory

calldata는 임시데이터 값을 변경하지 않아도 될때 사용합니다.

string _name을 calldata로 불러온 후 'cat'이란 문자열을 재할당 한다면 에러가 발생합니다.

```solidity
function addPerson(string calldata _name, number _favoriteNumber) public {
    _name: cat;
    people.push(People(_name, _favoriteNumber));
}
```

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20085514.png)

반면에 memory는 재할당이 가능합니다.

```solidity
function addPerson(string memory _name, number _favoriteNumber) public {
    people.push(People(_favoriteNubmer, _name))
}
```

storage는 재할당 가능한 영구적인 변수입니다.

데이터 로케이션 중 Stack, Code, Logs는 변수가 저장된다고 말할 수 는 없습니다. memory, storage, calldata만 가능합니다.
왜 그런지 나중에 더 알아보겠습니다.

- 왜 두번째 인수 uint256 _favoriteNumber는 memory가 필요없을까요?

uint256 에도 memory를 붙여서 parameter로 보내봅시다.

```solidity
function addPerson(string memory _name, number memory _favoriteNumber) public {
    people.push(People(_name, _favoriteNumber));
}
```

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20093504.png)

솔리디티 자체에서 이미 uint256이 어디에 저장되어야 하는지 알고 있기 때문입니다.
이 함수 내에서 uint256이 memory에 저장되어야 한다는걸 자동으로 알고있습니다.

반면에 string타입은 어디에 저장되어야 할지 모릅니다. 때문에 data location을 설정해줘야합니다.
array, struct, mapping 타입은 솔리디티에게 특별한 타입입니다.

string타입은 생각보다 복잡합니다. string은 bytes로 이루어진 array이기도 하기때문에 위의 에러메세지에 보이는 array 타입에 포함되어 memory가 필요합니다.

string에 storage를 주어도 에러가 발생합니다. 이것 또한 솔리디티가 이미 이 함수의 인수들이 memory로 임시적으로 사용될 것임을 알기때문입니다.

정리 -> struct, array, mapping 타입의 변수를 파라미터로 줄때 memory나 calldata 키워드를 반드시 붙여야 합니다.

뒷부분에서 storage, calldata, memory 에 대한 더 많이 알아보겠습니다.

### Basic Solidity Mappings

array 리스트는 정말 유용합니다. 그런데 만약 사람들의 100명 정도 되는 사람들의 이름만 알고 favorriteNumber를 모른다면 favortieNumber를 알아보기 위해 어떻게 해야할까요? people에 index를 일일이 대입하여 호출해야 할까요? 이름을 일일이 확인하고 좋아하는 숫자를 확인해야 할까요?
굉장히 비효율적일 겁니다.

더욱 효과적인 방법이 있습니다.

또다른 자료구조인 mapping입니다.
mapping은 자료구조로 key가 하나의 값에 "mapped"되어 있는 형태입니다. 마치 사전이라고 생각하시면 이해가 쉬울겁니다. 이 key들은 key에 묶인 값을 반환합니다.

```
mapping(string => uint256) public nameToFavoriteNumber;
```
string을 uint256에 매핑하는 타입이고 visibility는 public 이름은 nameToFavoriteNumber라는 변수입니다.

이제 각 문자열마다 특정한 uint256이 매핑된 사전을 가지게 되었습니다.

배포 후에 이름을 넣어보면 0을 반환합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20134646.png)

매핑을 만들었을때 모든 값들은 0으로 초기화되기 때문에 값들을 만들어줘야 합니다.

- 매핑을 addPerson에서 추가하도록 만들기

```solidity
function addPerosn (string memory _name, number _favoriteNumber) public {
    people.push(People(_favoriteNumber,_name));
    nameToFavoriteNumber[_name] = _favoriteNumber;
}
```
저장 후 재배포합니다.
addPerson 함수에 _name과 _favoriteNumber를 입력하고 실행합니다.
nameTOFavorite에 방금 넣은 _name 값을 넣어 매핑된 값을 출력하는지 봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20135146.png)

Kim에 매핑된 7값을 반환한 것을 확인 할 수 있습니다.

이번엔 people로 저장된 값을 불러와봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20135550.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20135602.png)

두번째로 addPerson한 Chad 도 값을 잘 출력합니다.

### Deploying your First Contract

이제 테스트넷을 이용해 웹에 직접 배포해봅시다.

컴파일 후 DEPLOY 탭으로 이동합니다.

이제 가상머신 (JavaScript VM) 대신 injcected Web3 나 Web3 Provider를 사용할 겁니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20140035.png)

injcected Web3는 메타마스크 같은 브라우저 지갑에 컨트렉트를 주입(injcect) 할거라는 뜻입니다.

faucet과 비슷하게 작동하는 겁니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20140333.png)

injcected Web3를 선택하고 메타 마스크 창이 뜨면 계정을 선택한 뒤 다음을 누릅니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20140436.png)

연결을 누릅니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20140504.png)

이제 DEPLOY탭을 보면 메타마스크 계정으로 연결된 걸 볼 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20140725.png)

Web3 Proivder는 endpoint를 정해서 좀 더 세부적으로 연결할 수 있습니다. 이 부분은 뒷부분에서 이해가 될 겁니다.

현재 지갑이 존재하는 테스트넷은 Rinkeby 고 이 계약은 Rinkeby 테스트넷에 배포되었습니다.

테스트넷 주소와 faucet 모음 :
https://docs.chain.link/docs/link-token-contracts/

Deploy 버튼을 눌러봅시다.

그러면 이번엔 메타마스크 알림창이 뜹니다. 그리고 이 계약을 정말 배포할 것인지 물어봅니다.

이 과정은 블록체인 원리를 알아볼때 예로 들었었던 트랜잭션에 서명(sign)하는 행위와 같습니다.

우리는 트랜잭션의 DATA를 sign 하고 sending 하는겁니다. 

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20142153.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20142504.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20142543.png)


이 계약을 배포하는데 필요한 Gas와 총합(Total) ETH 량이 표시됩니다.

이곳은 테스트넷이니 일단 confirm 합시다.

테스트넷 상태에 따라 시간이 오래걸릴 수도 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20142826.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20203704.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20203742.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20204143.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20204301.png)

배포가 완료되었습니다.

보시다시피 가스요금이 단순히 이더리움을 보내는 트랜잭션보다 훨씬 많이 드는 것을 볼 수 있습니다.

이제 배포한 컨트렉트 정보를 볼까요

Deployed Contracts에 주소를 Copy해서 Etherscan에서 검색합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20204459.png)

배포한 계약의 상태를 볼 수 있습니다.
첫 트랜잭션이 create contract인걸 확인할 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20205002.png)

파란버튼(view function)을 호출하면 메타마스크가 뜨지 않습니다.(gas 소모 x)

반면에 주황색버튼을 호출하면 메타마스크가 뜨면서 계약에 sign 후 컨펌을 요청합니다.

store 함수를 작동시켜보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20205652.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20205713.png)

confirm을 눌러서 확인합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20205832.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20205842.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20205850.png)

pending -> indexing -> success 순으로 트랜잭션 과정이 진행됩니다.

이 과정은 테스트 넷의 상태에 따라서 정말 오래걸릴 수도 있기 때문에 가장 마지막에 진행하는 것이 좋습니다.
저는 3시간 걸렸습니다.

이제 store 한 값을 retrieve로 불러와볼까요

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20210253.png)

정상적으로 값(17)을 가져왔습니다.

이번엔 addPerson 을 작동시켜봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20210652.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20210709.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-02%20210833.png)

이제 테스트넷에 배포가 완료되었고, 이더스캔에서 트랜잭션이 일어난 것을 직접 확인할 수 있습니다.
처음으로 테스트넷에 계약을 배포한겁니다. 축하합니다!

참고로 배포되는 테스트넷을 바꾸고 싶다면 Metamask에서 테스트넷을 바꾸면 remix에서도 해당 테스트넷으로 변경해 줍니다.
물론 faucet을 통해 transaction에 필요한 ETH를 준비해놓아야 겠죠?

### The EVM & A Recap of Lesson 2

- EVM, Ethereum Virtual Machine

Remix에서 컴파일버튼을 누르게 되면 코드를 EVM을 통해 컴파일하게 됩니다.

Avalanche, Fantom, Polygon 에서도 사용가능합니다.

이제 지금까지 작성한 코드의 순서를 복습해볼까요

1. pragma solidity ^0.8.8 -> 솔리디티 버전 알려주기
2. //SPDX-License-identifier: MIT -> SPDX 라이센스 설정하기
3. 계약(contract SimpleStorage {}) 작성하기 -> 다른 프로그램언어의 class 와 비슷한것
4. 데이터타입엔 uint, boolean, string 등 다양한 것이 있습니다.
5. 만약 새 타입을 작성하고 싶다면 `struct`를 이용하면 됩니다.
```solidity
struct People {
    uint256 favoriteNumber;
    string name;
}
```
6. 배열로 리스트를 만들 수 있습니다.
```solidity
People[] public people;
```
7. 매핑으로 키와 값을 쌍으로 가지는 해시테이블을 만들 수 있습니다.
```solidity
mapping(string => number) public nameToFavoriteNumber;
```
8. 블록체인 stat를 바꿀 수 있는 함수를 작성할 수 있습니다.

```solidity
uint256 favoriteNumber;

function store(uint256 _favoriteNumber) public {
    favortieNumber = _favoriteNumber;
}
```

```solidity
function addPerson(stirng memory _name, uint256 _favoriteNumber) public {
    people.push(People(_favoriteNumber, _name))
}
```
9. 또한 블록체인 상태(state)를 변경시키지 않는 함수도 만들 수 있습니다.
```solidity
//view, pure
function retrieve() public view retruns(uint256) {
    return favoriteNumber;
}
```
10. 임시로 사용하거나 영구적으로 사용할 데엍의 데이터 로케이션을 특정지을수도 있습니다.
calldata, memory는 임시
storage는 영구적입니다.

```solidity
//calldatat, memory, storage
function addPerson(string memory _name, uint256 _favoriteNumber) public {
    people.push(People(_memory, _favoriteNumber));
    nameToFavoriteNumber[_name] = _favoriteNumber
}
```

컴파일 버튼을 누르면 EVM specification(사양)이 이 코드를 컴파일 합니다. 나중에 사양에 대해서 더 자세히 알아볼 겁니다.

# Lesson 3 Remix Storage Factory

https://github.com/PatrickAlphaC/storage-factory-fcc

Just sit back Watch and enjoy

컨트렉트는 컨트렉트를 배포할 수 도 있습니다.

StorageFactory.sol 을 통해 다른 컨트렉트와 상호작용하여 컨트렉트를 배포할 겁니다.

DEPLOY 탭으로 가서 ENVIRONMENT를 다시 JavaScriptVM으로 설정해주고 CONTRACT란을 StorageFactory로 선택 후 Deploy 합니다.

다음과 같은 함수들이 보입니다.
createSimpleStorage는 이름에서 알 수 있다시피 SimpleStorage 계약을 만들어줍니다.

createSimpleStorage를 클릭해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20072641.png)

SimpleStorage 계약이 생성되었다면 이제 sfStore 함수를 이용해 상호작용이 가능합니다.

sfStore에 `0,1`(index 0 에 1의 값을 넣기) 값을 넣어보겠습니다.

그런다음 sfGet과 simpleStorageArray에 각각 0을 넣고 호출해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20073445.png)

sf Get에는 index0의 값 1이 반환되었고

simpleStorageArray(최하단파란버튼)에서는 방금 createSimpleStorage 버튼으로 deploy한 SimpleStorage의 address값을 반환합니다.

### Importing Contracts into other Contracts

컨트렉트에서 컨트렉트를 배포하고 배포된 컨트렉트와 상호작용하는 방법을 알아봅시다.

서로 다른 각각의 컨트렉트와 끊김없이(seamless) 상호작용하는 능력을 결합성(composability)이라고 합니다.

스마트 컨트렉트는 결합성이 있습니다. 왜냐하면 서로 상호작용하기 쉽기때문입니다.

This is specially awesome when it comes things like deFi or you can have really complex financial products interacts each other incredibly easily. since other code is available on-chain.
이런 특성은 DeFi 앱 같은 경우나 복잡한 금융관련 상품의 상호작용을 쉽게 만들어야 할 때 매우 유용합니다. 왜냐하면 체인상의 다른 코드를 사용할 수 있기 때문입니다.

이제 어떻게 하는지 배워볼 겁니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20081309.png)

저번시간에 이어서 작성한 워크스페이스에 StorageFactory.sol 파일을 만들어줍니다.

다음과 같이 기본설정을 해준 후 컴파일 후 저장해줍니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StorageFactory {
    
}
```

이제 계약을 배포하는 함수를 작성합니다.

전역변수로 createSimpleStroageContract를 저장했습니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StorageFactory {

    function createSimpleStorageContract() public {
        
    }

}
```

그렇다면 여기서 createSimpleStorageContrcat는 어떻게 simpleStorage의 생김새를 알까요?

이렇게 해봅시다. simpleStorage의 코드를 통째로 복사해서 StorageFacotory 코드에 붙여넣습니다.

```solidity

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleStorage {

    uint256 favoriteNumber;

    struct People {
        uint256 favoriteNumber;
        string name;
    }
    // uint256[] public anArray;
    People[] public people;

    mapping(string => uint256) public nameToFavoriteNumber;

    function store(uint256 _favoriteNumber) public virtual {
        favoriteNumber = _favoriteNumber;
    }
    
    function retrieve() public view returns (uint256){
        return favoriteNumber;
    }

    function addPerson(string memory _name, uint256 _favoriteNumber) public {
        people.push(People(_favoriteNumber, _name));
        nameToFavoriteNumber[_name] = _favoriteNumber;
    }
}


contract StorageFactory {

    function createSimpleStorageContract() public {
        // How does storage factory know what simple storage looks like?
    }

}
```

이렇게 만든 후 Deploy 해보면 작동하긴 합니다.
계약배포에도 simpleStorage와 StorageFactory 함수 두가지가 들어가 있습니다. 이처럼 하나의 솔리디티 파일에 두개이상의 계약을 가지는 것도 가능합니다.

이제 위에 있는 SimpleStorage도 StorageFactory안에서 전역변수로 선언해 보겠습니다.

그런 다음 createSimpleStorageContract함수 안에 new 키워드로 새 계약을 배포하겠다는 코드를 작성해줍니다.

```solidity
contract StorageFactory {
    SimpleStorage public simpleStorage;
    function createSimpleStorageContract() public {
        simpleStorage = new SimpleStorage();
    }
}

```

JavaScript VM 환경에서 CONTRACT를 StorageFacotory로 설정한 후 Deploy해보겠습니다.

simpleStroage를 호출하면 초기화된 address 주소가 반환됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20092851.png)

createSimpleStorageContract를 눌러 simpleStorage 계약을 하나 배포합니다.

다시 simpleStorage를 호출하면 해당 계약의 address가 보입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20093150.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20093251.png)

이렇게 계약이 계약을 배포하는 방법에 대해 알아보았습니다.

사실 simpleStorage를 만들기 위해 위에 복사해 놓은 코드들은 `import`를 이용해 다른 파일에서 불러들여오는것이 좋습니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SimpleStorage.sol";

contract StorageFactory {
    SimpleStorage public simpleStorage;

    function createSimpleStorageContract() public {
        simpleStorage = new SimpleStorage();
    }

}
```

여기에서 SimpleStorage.sol의 solidity 버전과 StorageFactory.sol의 solidity 버전이 다릅니다. 이 때 두 버전의 중간 버전 가까운 것을 임의로 선택 후에 컴파일하면 Remix에서 자동으로 적합한 컴파일러 버전을 설정해줍니다.

하지만 만약 StorageFactory.sol 이 0.7.0 버전이고 SimpleStorage 버전이 0.8.8 이라면 컴파일러 버전이 맞지 않는다고 에러가 발생합니다.

이번엔 SimpleStorage를 배열로 만들어 여러개의 계약을 받아 볼 겁니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SimpleStorage.sol";

contract StorageFactory {
    SimpleStorage[] public simpleStorageArray;

    function createSimpleStorageContract() public {
        SimpleStorage simpleStorage = new SimpleStorage();
        SimpleStorageArray.push(simpleStorage);
    }

}
```

배포 후 createSimpleStorageContract버튼을 여러번 누르고 SimpleSotrage버튼으로 index를 호출해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20102015.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20102035.png)


### Interacting with other contracts

이제 다른 계약을 추적할 수 있게 되었습니다.
그렇다면 상호작용은 어떻게 할까요?

만약 SimpleStorage 계약 안의 store 함수를 사용하고 싶다면 어떻게 해야할까요?

sfStore(storage factory Store)라는 이름으로 함수를 만들어보겠습니다.
이 함수는 uint256 인수 두가지를 받으며 visibility는 public입니다.

```solidity
contract StorageFactory {
    SimpleStorage[] public simpleStorageArray;

    function createSimpleStorageContract() public {
        SimpleStorage simpleStorage = new SimpleStorage();
        simpleStorageArray.push(simpleStorage);
    }

    function sfStore(uint simpleStorageIndex, uint256 simpleStorageNumber) public {

    }

}
```

외부 계약을 끌어다 쓰려면 몇가지 조건을 알고 있어야합니다.

1. Address
2. ABI - Application Binary Interface

ABI는 정확히 어떻게 계약과 소통해야하는지 알려줍니다.
나중에 더 자세히 다루겠습니다.

Remix의 COMPILE 탭에서 컴파일 후 Compliation Details 버튼을 눌러봅시다.
다른 계약의 정보에 대해서 리스트업 되어있는걸 확인 할 수 있습니다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20103013.png)

ABI도 있습니다. ABI는 계약의 input ouput으로 어떤 작업이 이루어지는지 정보를 담고 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20103249.png)

우리는 Address 값을 이미 알고 있습니다. simpleStorageArray에 담겨있으니까요.

마찬가지로 ABI도 import 해온 계약으로부터 알아낼 수 있습니다.

컴파일 하면 ABI와 함께 프리패키지 되기때문에 import "./SimpleStorage.sol"로 불러들인 순간 자동으로 ABI를 알고있는 상태입니다. 나중에 ABI를 따로 쉽게 불러오는 다른 방법도 알아볼 겁니다.

먼저 SimpleStorage 오브젝트를 불러옵니다.
SimpleStorage타입을 가진 simpleStorage라는 변수를 선언합니다.

여기선 new를 사용하지 않고 SimpleStorage()를 호출해서 SimpleStorage의 Address만 가져올 수 있도록 합니다.

Address를 가져올 수 있도록 인수(simpleStorageArray에 안의 index값)를 SimpleStorage()에 넣어줍니다.

아니면 아예 simpleStorageArray로 접근해서 _simpleStorageIndex를 사용해 해당 배열index의 계약을 simpleStorage 변수에 할당합니다.

```solidity
import "./SimpleStorage.sol";

contract StorageFactory {
    SimpleStorage[] public simpleStorageArray;

    function createSimpleStorageContract() public {
        SimpleStorage simpleStorage = new SimpleStorage();
        simpleStorageArray.push(simpleStorage);
    }

    function sfStore(uint256 _simpleStorageIndex, uint _simpleStorageNumber) public {
        // Address
        // ABI - Application Binary Interface
        SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
    }

}

```
이렇게 되면 새롭게 만든 simpleStorage 계약을 simpleStorageArray의 index n에 저장하고 다시 해당 index 안의 계약을 SimpleStorage 타입의 simpleStorage 변수에 할당한 것이 됩니다.

simpleStorageArray가 계속 address를 추적해 주고 있으며 때문에 ABI는 자동으로 함께 포함되어 들어오게 됩니다.

만약 위의 주석과 같이 SimpleStorage simpleStorage = SimpleStorage(simplesStorageArray[_simplestorage])로 작성한다면 SimpleStorage[] 배열은 address[]배열이 더 어울릴 것입니다. 왜냐하면 주소(address)값만 불러오기 때문이죠. 이 부분은 나중에 다시 확인해보도록 하겠습니다.

일단 지금은, simpleStorage 오브젝트에 대한 정보를 얻게 되었습니다.

이제 simpleStorage 에서 SimpleStorage계약 안의 store함수를 다음과 같이 사용할 수 있습니다.

```solidity
function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {
    SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
    simpleStorage.store(_simpleStorageNumber);
}

```

다른 함수도 불러와 보겠습니다.
이번엔 SimpleStorage 안의 getter 함수를 불러와 sfStore로 저장한 숫자를 불러와보겠습니다.

```solidity
function sfGet(uint256 _simpleStorageIndex) public view returns(uint256) {
    SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
    return simpleStorage.retrieve();
}
```

이제 아래 최종 완성 코드를 배포한 후에 실행해보겠습니다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SimpleStorage.sol";

contract StorageFactory {
    SimpleStorage[] public simpleStorageArray;

    function createSimpleStorageContract() public {
        SimpleStorage simpleStorage = new SimpleStorage();
        simpleStorageArray.push(simpleStorage);
    }

    function sfStore(uint256 _simpleStorageIndex, uint _simpleStorageNumber) public {
        // Address
        // ABI - Application Binary Interface
        SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
        simpleStorage.store(_simpleStorageNumber);
    }

    function sfGet(uint256 _simpleStorageIndex) public view returns(uint256) {
        SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
        return simpleStorage.retrieve();
    }

}
```
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20110301.png)

먼저 sfGet과 simpleStorage에 0을 각각 넣어보겠습니다.

아무일도 일어나지 않습니다.

다음은 createSimpleSotrageContract로 계약을 생성 한 후 simpleStorage에 0을 넣어보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20110413.png)

해당 계약의 주소를 불러왔습니다.

이제 sfStore로 index 0 에 숫자 7을 address가 0x3aD18EC437c396539C439CD1A4721B01F2800b1A 인 계약에 저장해보겠습니다.
그리고 다시 sfGet으로 해당 숫자를 호출합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20110649.png)

- 참고 : simpleStorage 버튼을 계약이 없는 index를 호출했을대 아무것도 뜨지 않지만 트랜잭션 로그에서 초기화 된 address 값을 확인 할 수 있습니다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20110752.png)

이해를 위해 더 간단하게 만들어볼까요?
sfGet함수는 이런식으로 바로 SimpleStore 오브젝트에 접근해서 오브젝트 안의 함수를 가져올 수도 있습니다.

```solidity
function sfGet(uint256 _simpleStorageIndex) public view returns(uint256) {
    return simpleStorageArray[_simpleStorageIndex].retrieve();
}

```

이처럼 StorageFactory 계약은 SimpleStorage의 매니저 역할을 하는 계약으로 사용할 수 있습니다.

### Inheritance & Overrides

만약 store 함수에서 favoriteNumber를 저장하는데 그치지 않고 `5`를 더해서 저장하는 기능을 만들고 싶다면 어떻게 해야할까요?

ExtraStorage.sol 이라는 파일을 만들어보겠습니다.

이때 simpleStorage를 포함하고 있는 StorageFactory계약을 불러오고 싶다면 `inheritance`를 사용하면 됩니다.

첫번재로 ExtraStorage에서 사용될 계약들을 모두 불러옵니다.
두번째로 계약 이름 뒤에 is를 붙여 불러온 계약의 이름을 붙여줍니다.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./SimpleStorage.sol";

contract ExtraStorage is SimpleStorage {

}
```
이렇게 하면 ExtraStorage는 SimpleStorage의 모든것을 상속받아 작동하게 됩니다. 컴파일 후 확인해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20121405.png)

SimpleStorage.sol의 모든 함수를 상속받아 사용 할 수 있습니다.

어떤 컨트렉트의 모든 기능(함수)들을 다른 계약에 상속해서 사용하고 싶다면 import로 계약을 불러온 뒤 상속받을계약 is 상속해줄계약 으로 작성하면 됩니다.

자, 여기서 상속받은 SimpleStorage의 함수중에 store 함수가 맘에 들지 않습니다. 내 입맛대로 바꿔서 사용하고 싶을땐 어떻게 해야 할까요?

store 함수는 현재 favoritNumber를 인수로 받아 저장하고 있습니다. ExtraStorage에선 store를 이용해 favoriteNumber + 5 의 값을 저장하려 합니다.

이럴때 `override` 키워드를 사용하면 됩니다.
여기엔 또 두가지의 키워드가 있습니다.
1. override
2. virtual

지금은 일단 언급한 키워드 없이 store 함수를 ExtraStorage에 그대로 옮겨서 구현해보겠습니다.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./SimpleStorage.sol";

contract ExtraStorage is SimpleStorage {
    // + 5
    // override
    // virtual override
    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber + 5
    }
}
```
컴파일 하면 다음과 같이 두가지 오류가 발생합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20122536.png)

부모 계약이 자식계약이 갖고 있는 함수를 갖고 있다면 solidity에게 override specifier를 이용해 해당 함수를 덮어쓴다고 알려줘야 합니다.
또한 덮어씌워질 원본 함수에는 virtual이라는 specifier를 붙여야 합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20124525.png)

SimpleStorage.sol의 store 함수의 visability 오른쪽에 `virtual` 지정자(specifier)를 추가해줍니다.
```
function store(uint256 _favoriteNumber) public virtual {
    favoriteNumber = _favoriteNumber;
}
```
ExtraStorage.sol의 store 함수의 visability 오른쪽에 `override` 지정자(specifier)를 추가해줍니다.
```
function store(uint256 _favoriteNumber) public override {
    favoriteNumber = _favoriteNumber + 5;
}
```
이제 컴파일 후 DEPLOY탭에서 ExtraStorage를 선택 후(확인필수) 다시 배포해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20130300.png)

simpleStore의 함수를 모두 갖고 있으면서,
store에 5를 넣으면 5를 더해서 10을 반환하고 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20130340.png)

### Lesso3 Recap

1. 계약자체를 타입으로 삼고 new 키워드를 이용해 계약이 새로운 계약을 만드는 방법에 대해 알아보았습니다.
```
contract StorageFactory {
    SimpleStorage simpleStorage = new SimpleStorage()
}
```

2. import를 통해 다른 계약을 불러오는 방법을 배웠습니다.
```
import "./불러오고싶은계약.sol"
```

3. 다른 계약과 상호작용하려면 Address와 ABI가 필요하다는 걸 배웠습니다.

4. 자식계약에게 부모계약을 상속하고 싶다면 inheritance를 사용하면 된다는 걸 배웠습니다. import로 해당 계약을 불러온 뒤 contract 자식계약 is 부모계약 {}으로 상속(inheritance)을 구현할 수 있습니다.

5. 부모계약의 함수를 변형하여 사용하고 싶다면 자식함수에 구현된 부모함수와 똑같은 이름의 함수에 override 지정자를 사용해야 한다는 걸 배웠습니다.
또한 덮어씌워지는 해당 부모함수에 virtual 지정자를 사용해야 한다는 것도 배웠습니다.

# Lesson 4 Remix Fund Me

fund() 와 withdraw()를 이용해서 모금하고 출금하는 DeFi앱을 만들어 볼 겁니다.

## Sending ETH Through A function & Reverts

FundMe.sol 파일을 만들어보겠습니다.

```solidity
// 사용자로부터 펀딩기금 받아오기
// 모금된 기금 인출하기
// 달러로 최소 펀딩 금액 설정하기

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

contract FundMe {
    
    function fund() {

    }
    
    function withdraw() {

    }
}
```

FundMe 컨트렉트를 작성한 후 
사용자가 돈을 보내기 위한 fund(),
마련한 돈을 인출하기 위한 withdraw()
두가지 주요함수를 작성합니다.

일단 fund안에서 최소 후원금액(USD)를 설정할 겁니다.
생각해봐야 할것이 몇개 있습니다.

1. 어떻게 이 계약으로 ETH를 보낼까요?

-> remix의 DEPLOY 탭의 `VALUE` 인풋에서 보낼 ETH의 양을 정할 수 있습니다.
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20212901.png)

데이터 필드
### Transaction Fields
- Nonce: tx count for the account
- GasPrice : price per unit of gas (in wei)
- GasLimit : max gas that this tx can use
- To: address that the tx is sent to
- Value : amount of wei to send
- Data : What to send to the To address
- v, r, s: components of tx signature

데이터를 보낼때
### Transactions - value Transfer
- Nonce : tx count for the account
- Gas Price : price per unit of gas (in wei)
- Gas Limit : `21000`
- To: `address that the tx is sent to`
- Value: amount of wei to send
- Data: `empty`
- v, r, s: components of tx signature

벨류값의 데이터 중에는 이미 자동으로 입력되어있는(populated) 값들이 있습니다. 
Gas Limit, To, Data 가 그렇습니다.

함수를 호출할때도 입력할 수 있는 데이터가 있습니다.

Transactions - Function Call
- Nonce: tx count for the account
- GasPrice : price per unit of gas (in wei)
- GasLimit : max gas that this tx can use
- To: `address that the tx is sent to`
- Value : amount of wei to send
- Data : `What to send to the To address`
- v, r, s: components of tx signature

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20223707.png)

VALUE 단위인 Wei Gwei Finney Ether

### payable
스마트 컨트렉트가 지갑처럼 자금을 가질 수 있게 만듭니다.

배포할때마다 지갑주소와 비슷한 주소를 가지게 됩니다.

Remix에서 이 지정자가 들어간 함수는 빨간 버튼으로 표시됩니다.

```solidity
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

contract FundMe {

    function fund() public payable {

    }
}
```
지갑과 컨트렉트 모두 네이티브 블록체인 토큰(이더리움 같은)을 가질 수 있습니다.

배포할 때 이더리움 자금을 가지게 되는걸 확인 할 수 있을겁니다.

payable을 사용하면 DEPLOY탭에 있는 VALUE 에 접근할 수 있습니다.

얼마나 많은 value를 보낼 것인가는 다음과 같은 전역변수(msg)를 사용해 표현합니다.
`msg.value;`

그렇다면 사용자가 이더리움을 보낼때 최소 1이더리움을 보내게 하려면 어떻게 해야할까요?
바로 `require` 키워드를 사용하면 됩니다.

`require(msg.value > 1e18);`

여기서 `1e18 == 1 * 10 ** 18 == 1000000000000000000` 입니다.

이더리움은 wei단위로 계산합니다. 따라서 1ETH는 1e18 값으로 설정해야합니다.

`require`는 일종의 체커입니다. msg.value 가 1e18 보다 큰가요? 아니라면 require의 두번째 인수인 `revert`로 넘어갑니다.

- Solidity 에서 한글쓰기
https://ethereum.stackexchange.com/questions/97173/do-solidity-smart-contract-symbols-support-unicode
유니코드 이스케이프 문자를 쓰거나, unicode 키워드를 문자열앞에 붙여주면 됩니다. ex)`string memory greeting = unicode"안녕하세요"` or `"\ucd5c\uc18c\u0020\ud380\ub529\uae08\uc561\uc5d0\u0020\ubbf8\ub2ec\ud569\ub2c8\ub2e4\u002e"`

```solidity
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

contract FundMe {

    function fund() public payable {
        // 달러로 최소 금액을 설정하려 합니다.
        // 1. 어떻게 이 계약으로 ETH를 보낼까요?
        require(msg.value > 1e18, unicode"최소 펀딩금액에 미달합니다.");
    }

    // function withdraw(){}

}
```
이제 JavaScript VM에 배포해봅시다.

payable 함수는 다음과 같이 붉은색 버튼으로 표시됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20231041.png)

버튼을 누르면 로그에 에러가 출력됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20231638.png)

revert 메세지가 출력된걸 볼 수 있습니다.

require가 value를 보낼 필드가 필요합니다.
DEPLOY 탭의 VALUE 값을 2로 설정해보겠습니다.
그런다음 다시 `fund`를 호출합니다

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20231854.png)

Wei를 Ether로 바꿔줍시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20232010.png)

트랜잭션이 성공했고, 2000000000000000000 wei가 전송된 걸 확인 할 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20232104.png)

`require(msg.value > 1, unicode"금액이 부족해요..")`

리콰이어는 이렇게 작동합니다.

`if msg.value >1 else unicode"금액이 부족해요.."`

그런데 `revert`가 정확히 뭘 하는걸까요?

-> **이전 행동을 취소하고, 남아있는 가스를 되돌려 보냅니다.**

예를 들어 전역변수로 number를 지정하고 이를 fund함수에서 불러와 보겠습니다.

```solidity
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

contract FundMe {

    uint256 public number;

    function fund() public payable {
        // 달러로 최소 금액을 설정하려 합니다.
        // 1. 어떻게 이 계약으로 ETH를 보낼까요?
        number = 5;
        require(msg.value > 1e18, unicode"최소 펀딩금액에 미달합니다.");
    }

    // function withdraw(){}

}
```

fund 함수를 VALUE가 0인 상태로 호출해보겠습니다.

그렇게 되면 fund함수가 호출되고 number = 5;로 설정되지만 require에서 msg.value가 0이기 때문에 이전 행동 즉, number = 5; 할당을 취소하게 됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20233848.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-03%20233936.png)

따라서 number를 호출하면 여전히 0의 값을 보여주게 됩니다.

이 과정이 가스를 소모했을까요? 네, 그렇습니다. 
number를 5로 바꾸기 위해 사용했습니다. 그리고 남은 모든 가스들은 require로 넘어가서 반환되었습니다.

예를 들어 다음과 같이 require 다음에 많은 연산을 한다고 가정해봅시다.
그렇게 되면 require 다음에 오는 연산들에 소모되는 가스들은 모두 다시 되돌려집니다.

```solidity
function fund() public payable {
    number = 5; // -> 이 가스는 소모되었고 반환되지 않습니다.
    require(msg.value > 1, unicode"최소 펀딩금액에 미달합니다.");
    // 이후에 많은 다른 연산들 진행 -> 이것들에 의해 소모된 가스는 모두 다시 반환됩니다.
}
```

revert에 대한 개념이 지금은 잘 이해되지 않을 수 도 있습니다. revert로 할 수 있는 다른 기능도 알아볼테니 나중에 더 자세히 살펴봅시다.

## Chainlink & Oracles

현재 최소 금액을 달러가 아닌 ETH(정확히는wei)로 설정해 놓았습니다. 이제 이 부분을 달러로 바꾸어 표시합니다.

먼저 최소 USD 달러 값을 FundMe 컨트렉트 안에 설정합니다.

`uint256 public minimumUsd = 50;`

이 값을 업데이트하기 할때 더 효율적인 가스사용을 위한 방법에 대해 알아볼 겁니다.

이제 ETH를 USD로 변환하기 위해서 오라클 네트워크가 필요합니다.

여기서는 Chainlink를 사용할 겁니다.

USD 단위는 오프체인 환경(현실)에서 우리가 약속한 단위입니다. 그렇다면 블록체인 바깥의 값(USD)와 소통하기 위해서 분산된 오라클 네트워크(Decentralized Oracle Network)가 필요합니다.

더 진행하기 전에 최선의 방법으로 FundMe 컨트렉트 완성을 위해 분산 오라클 네트워크 아키텍처에 대해서 짚고 넘어가겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20121358.png)

전에 얘기했듯이 블록체인 스스로는 현실 데이터와 이벤트에 접근할 수 없습니다. 블록체인이 이더리움의 가치에 대해서 모르고, 바깥 날씨가 화창한지 모르고, 기온이 얼만지도 모르고, 대통령이 누군지도 모르고 이런 모든 정보에 대해서 아무것도 모릅니다. 블록체인 또한 외부의 계산을 할 수 없습니다. 놀라운 인공지능을 개발해서 스마트 컨트렉트에 심는다면 가능할지도 모르겠습니다. 하지만 스마트 컨트렉트 스스로는 아무것도 할 수 없습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20122416.png)

앞서 언급했다시피, 이것이 블록체인이 디자인(설계)에 의해 결정된다는 이유입니다.

Non-deterministic 처럼 노드마다 랜덤데이터나 서로다른 값들을 가지고 있어 결과값이 같지 않을 것이고 다른 노드는 다른 결과를 초래하고 결코 합의(컨센서스)에 도달하지 못할것입니다.

이것이 스마트 컨트렉트 연결성 문제(The Smart Contract Connectivity Problem)라 알려진 것이며, 오라클 문제(The Oracle Problem)라고도 부릅니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20122956.png)

이건 달갑지 못한 소식입니다. 왜냐면 우리는 스마트 컨트렉트가  전통적인 계약을 대체하길 원하기 때문이죠.

그리고 전통적인 계약은 데이터가 필요하고 현실세계와 상호작용이 필요합니다. 

그리고 이것이 체인링크와 블록체인의 오라클이 자리잡은 이유입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20123910.png)

블록체인오라클(blockchain Oracle)은 스마트 컨트렉트 데이터 제공 혹은 계산을 위해 오프체인 세계와 상호작용하는 모든 장치입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20130832.png)

하지만, 이야기는 거기에서 끝이 아닙니다. 만약 우리가 중앙화된 오라클을 사용한다면, 우리는 실패한 부분을 재도입(reintroducing)하게 됩니다. 우리는 이 모든일을  로직 레이어를 분산(탈중앙)시키기 위해 한겁니다. 그러나 우리가 중앙화된 노드나 중앙화된 API 를 통해서 데이터를 가지고 온다면, 우리는 우리 스스로 API 를 부르게 되는것이고, 우리가 없애기 위해 엄청나게 노력한 이러한 신뢰장악을 재도입하게 되는것입니다. 스마트 컨트렉트 구측의 모든 목적을 망치는것입니다. 그래서 우린 중앙화된 노드를 통해 데이터를 얻거나 계산을 하지 않을겁니다. 

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20130851.png)
체인링크가 해결책입니다. 체인링크는 스마트 컨트렉트 안으로 데이터 가져오기와 외부 연산을 위한 분산화 오라클 네트워크입니다. 전에 말했듯이, 이것이 온체인과 오프체인에 결합된 경이롭도록 풍부한 기능을 가진, 막강한 어플리케이션인 하이브리드 스마트 컨트렉트의 시작이 되었습니다. 체인링크는 모듈화된 분산 오라클 네트워크로 원하는 데이터와 외부 연산을 커스터마이즈해서 보낼 수 있습니다.

다시 코드로 돌아가보겠습니다.

이부분에서 많은사람들이 이렇게 생각합니다.
" 여기서 HTTPS 가 API를 불러들여와야겠다. 그럼 되겠지"
블록체인 노드는 ex)https://api 이러한 HTTPS 호출을 할 수 없습니다. 왜냐면 HTTPS 호출은 컨센서스에 도달하지 못하기 때문입니다. 만약 HTTPS가 노드를 다른 시간에 호출하거나 다른 작업을 한다면, 모든 컨센서스는 파기되게 됩니다. 그래서 대신에, 우리는 체인링크 분산형 오라클 네트워크가 필요합니다. 그리고 트랜잭션중에 이 노드(FundMe)의 네트워크는 데이터를 스마트 컨트렉트에 사용하기 위해 변환할 것입니다. 

체인링크는 상호작용에 있어서 커스터마이즈를 지원합니다.
커스터마이즈를 위해선 추가로 작업해야 할 것들이 있습니다.
완전히 분산된 상태로 제공되는 수많은 기능들이 스마트 컨트렉트에 즉시 사용할 준비가 되어있습니다.

어떤 기능들이 있을까요?
1. Chainlink Data Feeds :
Powering over $50 bilion in the DeFi World
첫번째로 체인링크 데이터 피드 기능입니다.
이 기능을 이 어플리케이션에서 사용할 겁니다.

그들이 작동하는 곳은 체인링크 노드들이고 , 다른 교환처 그리고 데이터제공자로부터 데이터를 받고, 그 데이터들을 분산화된 체인링크 노드를 통해 들여옵니다.

체인링크 노드는 미디언(medium)을 이용해서 에셋이 실제 얼마의 가격(prcie)인지 알아냅니다. 그리고 그걸 하나의 트랜잭션에 가져다줍니다. 다른 스마트 컨트렉트가 쓸 수 있는 체인들(레퍼런스 컨트렉트, 프라이스 피드 컨트렉트, 데이터 컨트렉트)에게 전달해 줍니다.

그러면 그 스마트 컨트렉트는 price 정보를 통해서 디파이 어플리케이션을 작동시킵니다.

https://data.chain.link

이곳에서 가상화폐단위를 확인하고 변환 할 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20180319.png)

ETH USD example을 살펴보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20180536.png)

ETH USD에서는 각각의 노드가 ETH USD가격에 대해 서로 다른 응답을 가지고 있는 독립된 체인링크 노드 오퍼레이터의 전체 네트워크를 볼 수 있습니다. 이것들은 네트워크에 의해 집계되었고, 체인에 전달되었습니다. 

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20181244.png)

Trigger parameters:
Deviation threshold, Heartbeat

얼마나 자주 업데이트 하는지 확인 할 수 있습니다.
이러한 항목은 현재 0.5% 의 편차임계값이나 3600초의 heartbeat중 하나라도 도달하면 업데이트 됩니다.

최종 업데이트가 언제인지 볼 수 있고, 오라클 응답의 수도 볼 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20184147.png)

체인에서 직접 컨트렉트 주소도 볼 수 있고, 심지어 이더스캔에서 컨트렉트를 볼수 있고, 기록도 볼수있습니다.
서로 다른 오라클의 모든 응답을 볼 수 있습니다.
그리고 맨 끝에서 이 네트워크를 유지하는 사용자와 스폰서들을 볼 수 있습니다.


트랜잭션 가스와 비슷하게, 노드 운영자(operator)가 스마트 컨트렉트에 데이터를 전달할 때마다, 체인링크 노드 운영자는 체인링크 토큰에서 약간의 오라클 가스를 보상받습니다. 

![현재데이터피드모델](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20221128.png)

현재의 데이터피드 모델입니다.

A network of these chainlink nodes, each reaches out and gets the information about an asset and then signs the data with their own private key. In a single transaction, then, one node will deliver all the data with all the different signatures to a reference contract. If that node doesn't deliver the data, another node will send it instead. Reputation is incredibly important when your chainlink node operator. If you miss data updates, If you forget to send transactions, you'll probably be quickly kicked off these networks and have no chance of making any more money in the future. 

이러한 체인 링크 노드의 네트워크는 각각 자산에 대한 정보를 얻고 자신의 개인 키로 데이터에 서명합니다. 단일 트랜잭션에서 하나의 노드가 모든 서로 다른 서명이 있는 모든 데이터를 참조 계약으로 전달합니다. 해당 노드가 데이터를 전송하지 않으면 다른 노드가 대신 데이터를 전송합니다. 체인 링크 노드 운영자에게 평판은 매우 중요합니다. 데이터 업데이트를 놓치는 경우 트랜잭션을 보내는 것을 잊으면 이러한 네트워크에서 빠르게 퇴출되고 앞으로 더 이상 돈을 벌 기회가 없습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20222116.png)

These data feeds are used by some of the largest protocols in the space, such as 'Synthetics', 'SushiSwap', 'Compound' and 'AAVE', with several billion dollars each.


이러한 데이터 피드는 '합성', '스시스와프', '복합', 'AAVE'와 같은 공간 내 가장 큰 프로토콜에 의해 사용되며, 각각 수십억 달러씩이다.

We can take a look at an example over at 'http://docs.chain.link'

'http://docs.chain.link'에서 예를 살펴볼 수 있습니다.

EVM contracts로 작업할땐 EVM chains를 선택하고 DATA FEEDS 로 스크롤을 내린다음 솔리디티 섹션으로 가십시오.
그럼 trending price feeds의 읽기와 사용 컨트렉트 전체 예시를 볼 수 있습니다. 심지어 리믹스에서도 읽을 수 있습니다. 열어보면 kovan 네트워크 계약의 예시가 있습니다. 추후에 테스트넷이 아니라 실제 네트워크에서 어떻게 체인링크와 함께 작동하는지 심화해서 살펴볼 겁니다.

faucet에서 kovan네트워크의 ETH를 받기위해 이동합니다.

메타마스크 테스트넷을 kovan으로 변경합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20223329.png)

docs를 읽을때 항상 적혀있는 테스트넷에 맞춰서 테스트 하세요.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20223544.png)

솔리디티에서 데이터피드 이용 예제코드 : https://docs.chain.link/docs/get-the-latest-price/#solidity

예제 코드를 열고 컴파일 합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20223808.png)


ENVIORNMENT를 injected web3로 설정한 후
CONTRACT를 PriceConsumerV3로 선택하고 Deploy합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20224022.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20224206.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20224244.png)

Deployed Contract를 펼쳐서 getLatestPrice를 눌러보면 ETH가 달러로 변환된 값이 반환됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20224336.png)

변환된 값이 이상한 `176996000000` 값이 나오는데 이는 솔리디티에서 소숫점이 제대로 작동하지 않기 떄문입니다.

There is a decimals flag associated with this price feed address. that tells us how many decimals to include with this price.

이 프라이스 피드 주소와 연결된 소수 플래그가 있습니다. 이 가격에 포함할 소수 자릿수를 알려줍니다. 이는 개발자 문서에도 포함되어 있습니다.

솔리디티에서 데이터피드 이용 예제코드 : https://docs.chain.link/docs/get-the-latest-price/#solidity

소수점 플래그 : https://docs.chain.link/docs/price-feeds-api-reference/#decimals

// $1,769.96000000

프라이스피드 활용하기

만약 다른 프라이스 피드 주소를 찾고 있다면 contract addresses 항목을 참조하면 됩니다.

https://docs.chain.link/docs/ethereum-addresses/

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20230154.png)

여기서 이 Proxy 주소가 1 INCH 토큰을 ETH으로 변환해서 가격을 알려줄 겁니다.

세번째 AAPL 은 애플 주식을 USD 단위로 알려줄것이고, 나머지 목록들도 이런식으로 사용할 수 있습니다.

그 다음 바로 사용할 수 있는 분산 어플리케이션은 `Chainlink VRF` 입니다.

### Chainlink VRF, Chainlink Verifiable random dysfunction

Securing Randomness for your applications.

나중에 해볼 복권 어플리케이션 예제를 하기전에, 어떻게 블록체인에서 무작위성(randomness)이 조작되는지에 대해서 살펴보겠습니다. 

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20231247.png)

Blockchains are deterministic system, which by definition means that they can't have randomness. If you can determine what a random number is, it's not a really random anymore, is it? So we need to wait to get a provably random number by looking outside of the blockchain. And Oracle's are perfectly positioned to do exactly that.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20231604.png)

Chainlink verifiable randomness function is way to get provably a random number into our smart contract to guarantee fairness and guarantee randomness of applications. 

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20231821.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20231934.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20232136.png)
Many protocols like 'Pooltogether', 'x infinity', 'Ether Cards', 'Avocado Cheese' and more use Chainlink VRF for lotteries, randomizing NFT's for gaming and for more, we're going to do an example of chainlink VRF in a later section. Once we get to the lottery section. if you want to see if you can play with the randomness yourself right now, I recommend you go into Doc's chainlink -> EVM chains, and scroll down to get a random number. And this will teach you how to get a provaly random number into your applications.

### Chainlink Keepers
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20232624.png)

Decentralized Event-Driven Execution

The next decentralized out of the box feature of chainlink is chainlink keepers, which is decentralized event driven execution.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20232653.png)
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20233331.png)
As we've seen in order to kick off some type of transaction, somebody needs to spend the gas and somebody needs to sit down and hit the go button or hit the transact button or hit the send button. But this is obviously a centralized vetor. If you have a decentralized application that needs to run at specific times, or after specific events are trigger. Chainlink keepers are the solution to this. Chainlink keepers are chainlink nodes that listen to a registration contract for different events that you specify to fire. Maybe you say every 10 minutes, you want to do someting or once a week do something or if the price of some acid hits some number, or maybe a liquidity pool is at a certain level, whatever envet that you want to code, you absoulutely can. the chainlink nodes constantly listen for these triggers to happen and check the different contracts for these triggers. Once a trigger returns true, the chainlink nodes will then perform whatever action that you tell the chainlink nodes to do, we're also not going to go over the chainlink keepers examples right now, because we're going to get to them in a later module. However, if you want to try them out, go to https://docs.chain.link/docs/chainlink-keepers

and go to Making Compatible Contracts and feel free to read the documentation. Try it out yourself.


![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-04%20233755.png)

The last of the box feature of chainlink is the most customizalbe, but also the hardest to get correct end to end reliability is the ultimate promise of our smart contracts. And we want and need them to be able to do anything, we want to be able to take any input and get any output making HTTP GET HTTP POST request is an easy way to customize our chainlink nodes to be able to do anything. Remember how we talked about making API calls that blockchain nodes themselves can do that?
Well, chainlink nodes can do that chainlink nodes can make direct requests to any APi that you specify. In order to do this, you both have to choose the chainlink node and the URL /data to send the request to. This is a little bit trickier than Chainlink VRF keepers or price feeds because you then have to responsible for creating the Chainlink network that gets data from many different chainlink nodes and many different data providers. But let's look an example in remix anywats. For this Section,

예제 코드 : https://docs.chain.link/docs/single-word-response/

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import '@chainlink/contracts/src/v0.8/ChainlinkClient.sol';
import '@chainlink/contracts/src/v0.8/ConfirmedOwner.sol';

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
 */
contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Kovan Testnet details:
     * Link Token: 0xa36085F69e2889c224210F603D836748e7dC0088
     * Oracle: 0x74EcC8Bdeb76F2C6760eD2dc8A46ca5e581fA656 (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0xa36085F69e2889c224210F603D836748e7dC0088);
        setChainlinkOracle(0x74EcC8Bdeb76F2C6760eD2dc8A46ca5e581fA656);
        jobId = 'ca98366cc7314957b8c012c72f05aeeb';
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);

        // Set the URL to perform the GET request on
        req.add('get', 'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD');

        // Set the path to find the desired data in the API response, where the response format is:
        // {"RAW":
        //   {"ETH":
        //    {"USD":
        //     {
        //      "VOLUME24HOUR": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add("path", "RAW.ETH.USD.VOLUME24HOUR"); // Chainlink nodes prior to 1.0.0 support this format
        req.add('path', 'RAW,ETH,USD,VOLUME24HOUR'); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10**18;
        req.addInt('times', timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
    }
}

```

HTTP 요청 예제를 테스트하기 위해 파우셋에서 link토큰을 받아야 합니다.

https://faucets.chain.link/

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20131634.png)

링크토큰을 받은 후 반드시 메타마스크에서 import(토큰가져오기) 해줘야 합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20131733.png)

link토큰의 네트워크 별 주소는 여기서 볼 수 있습니다.

https://docs.chain.link/docs/link-token-contracts/#kovan

여기서는 kovan 네트워크를 사용할겁니다.

토큰 주소를 복사해서 붙여넣으면 자동으로 기호와 십진수 값을 지정해 줍니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20131942.png)

ETH 아래 LINK 가 추가되었습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20132041.png)

아래의 세팅으로 deploy 합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20133117.png)

여기서 requestVolumeData를 살펴보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20133252.png)

requestVolumeData가 사실 API call을 만들어줍니다.
전에 말했듯이 체인링크에 데이터를 요청하면 오라클 가스(LINK토큰)을 지불합니다.

처음에 받은 LINK 토큰을 가지고 진행하겠습니다(LINK토큰은 ERC 677 토큰입니다. ERC 677 토큰은 ERC 20 토큰으로부터 함수를 상속받은 토큰으로 데이터를 페이로드에 넣어 전송할 수 있습니다.)

이제 이 오라클가스(LINK토큰)을 APICONSUMER에 보내기 위해 방금 배포한 APICONSUMER 계약의 주소를 복사합니다.

메타마스크의 보내기(Send)버튼을 눌러 복사한 주소를 붙여넣고 보냅니다.

에셋(자산)을 LINK로 바꾼 뒤 0.2LINK를 전송합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20134909.png)

0.2LINK를 보낸 이유는 테스트 예제에 0.1LINK라고 적혀있기 때문인데 버전이 바뀌면서 fee가 사라진것 같아요...

volume을 호출해보겠습니다.

초기값인 0으로 나오는데, 지난 24시간의 ETH volume을 조회하기 위해서 해당 주석을 참고하면 구조를 알 수 있습니다.

```solidity

// Set the URL to perform the GET request on
        req.add('get', 'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD');

        // Set the path to find the desired data in the API response, where the response format is:
        // {"RAW":
        //   {"ETH":
        //    {"USD":
        //     {
        //      "VOLUME24HOUR": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add("path", "RAW.ETH.USD.VOLUME24HOUR"); // Chainlink nodes prior to 1.0.0 support this format
```

더 명확하게 확인하기 위해 api요청 endpoint로 직접 이동해보겠습니다.

https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD

여기서 VOLUME24HOUR 값을 들여올 겁니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20140324.png)

하나의 트랜잭션에 요청을 만들고, 두번째 트랜잭션엔 볼륨값을 받아 volume 전역변수에 저장할 것입니다.

```solidity
    /**
     * Receive the response in the form of uint256
     */
    function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }
```

Deploy탭에서 주황색버튼 requestVolumeData를 호출해보겠습니다.
메타마스크가 뜨면 컨펌을 눌러주면 됩니다.
그리고 알겠지만 volume 값이 업데이트 되지 않습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20140824.png)

트랜잭션이 끝난 후(fulfill) 다시 volume버튼을 눌러보면 ETH volume 들어와 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20140931.png)

잠깐의 딜레이 후 체인링크 노드가 API 콜백을 다시 이 계약으로 보내줍니다.

나중에 이 과정에 대해서 더 자세히 알아보겠습니다.

나중에 배울 chainlink VRF, keeper 의 실무적용을 위해 실습해 본 것입니다.

## Review of Sending ETH And Working with Chainlink

논점을 벗어난 이야기가 길어졌습니다. 간단하게 복습을 해보겠습니다.

이더리움을 보내거나 다른 네이티브 블록체인 토큰을 함수를 통해 보낼때 항상 payable을 붙여주어야 합니다.

`require(성공조건,실패시행동);`를 이용해 트랜잭션이 성공할 경우와 실패할 경우 동작을 설정할 수 있습니다.

트랜잭션에 보낼 이더리움이나 블록체인 네이티브 토큰의 값에 접근하고 싶다면 전역변수`msg.vlaue`를 사용하면 됩니다.

chainlink data feed: 외부 데이터 정보를 받을 수 있는 서비스 -> 화폐단위 등등

chainlink VRF: provably(증명가능한) 외부 무작위 수를 생성할 수 있는 서비스

chainlink keeper: 이벤트 주도 외부 계산을 할 수 있는 서비스 if를 이용한 트리거 사용가능

Connect to any api: 분산시스템을 통해 API 연결가능

## Interfaces & Price Feeds

```solidity
// 사용자로부터 펀딩기금 받아오기
// 기금 인출하기
// 달러로 최소 펀딩 금액 설정하기

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

contract FundMe {

    uint256 public minimumUsd = 50;
    // uint256 public number;

    function fund() public payable {
        // 달러로 최소 금액을 설정하려 합니다.
        // 1. 어떻게 이 계약으로 ETH를 보낼까요?
        // number = 5;
        require(msg.value >= minimumUsd, unicode"최소 펀딩금액에 미달합니다.");
        // revert 될 경우 이후 액션에서 소모된 가스는 반환됩니다.
    }

    // function withdraw(){}

}
```
먼저 변환된 비율을 받아야 합니다.

Using Data Feeds 예제 코드에 있는 AggregationV3Interface 는 getLatestPrice 안에 있는 int price와 나머지 데이터들을 불러올 수 있습니다.

먼저 getPrice()함수를 작동시키기 위해선 프로젝트 바깥의 함수에서 가져와야 합니다. 저번 시간에 배웠듯이
1. ABI
2. Address

두가지 값이 필요합니다.

Address는 가져오는건 간단합니다. chainlink data feed 문서에 가서 원하는 테스트넷 에 있는 목록 중 원하는 주소를 가져오면 됩니다. 여기선 Rinkeby ETH/USD 주소를 사용하겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20161038.png)

ETH/USD 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e

ABI값은 어떻게 구할까요?
솔리디티엔 interface라는 개념이 있습니다. 한 번 살펴봅시다.

https://github.com/smartcontractkit/chainlink

이 레포지토리로 가서 AggregatorV3Interface를 살펴봅시다.

 https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  // getRoundData and latestRoundData should both raise "No data present"
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}
```

안을 살펴보면 많은 함수들이 선언만 되어있을 뿐 내용이 구현되어있지 않습니다.

이것이 바로 interface라 불리는 것입니다.
만약 이 파일을 컴파일 하면 사실상 계약의 ABI를 얻을 수 있습니다. 왜냐하면 계약과 상호작용는 서로 다른 모든 방법에 대해 정의하고 있기 때문입니다. 사실 이 함수가 어떤 일을 하는지 말해주지는 않지만, 괜찮습니다. 왜냐하면 우리가 함수가 사실 어떤일을 하는지 알 필요가 없기 때문입니다. 그것들은 모두 계약에 저장 될겁니다. 그래서 우리가 할 수 있는 건 우린 이 코드에서 인터페이스를 가져와서 리믹스에 붙여넣는 것입니다.
하지만 잠시만 기다리십시오. 이것보다 쉬운 방법이 있습니다. 보기만 하세요 일단

인터페이스 코드를 붙여넣었다면 이제 API 호출이 가능합니다.


```solidity
    function getPrice() public {
        // ABI
        // Address 
        AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404).version()
    }

```
getPrice에서 AggregatorV3Interface를 불러온 뒤 인수로 Rinkeby BTC/USD 주소를 넣어줍니다.

해당 주소가 유효하면 interface 안에 있는 version 함수를 사용할 수 있습니다.

즉, version 함수를 `0xECe365B379E1dD183B20fc5f022230C044d51404` 주소를 가진 계약에서 호출한 겁니다.

이제 version을 함수로 따로 빼내보겠습니다.

uint256 값을 반환하는 함수 getVersion을 작성하고
AggregatorV3Interface 타입의 객체 priceFeed를 만듭니다.

```solidity
function getVersion() public returns (uint256) {
    AggregatorV3Interface priceFeed = AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404)
    return priceFeed.version();
}

```

이제 오라클과 작업하기 위해 지금 바로 사용할 수 있는 실제 테스트넷이 필요합니다. hardhat 과 자바스크립트 환경으로 이전해서 로컬에서 테스트한다면 훨씬 쉬워지고 빨라질것입니다. 다만 현재 테스트넷에서 테스트하려면 조금 오래걸립니다.

Rinkeby 테스트넷으로 바꾼 뒤 배포하고 getVersion을 호출하면 '4'를 반환하고 이 pricefeed가 버전 4라는 사실을 알 수 있습니다. 이것이 프로젝트 외부에 이미 존재하고 있는 계약과 상호작용하는 매우 쉬운 방법입니다.

## Importing from GitHub & NPM

로컬에 AggregationV3Interface 파일을 만들어 import하는 방법도 있지만 GitHub(npm package)으로 직접 연결하는 방법도 있습니다.

```
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
```

```
npm i @chainlink/contracts
yarn add @chainlink/contracts
```
이 명령어는 GitHub로 부터 직접 코드를 import해옵니다.
리믹스는 github에서 만들어진 코드를 npm package를 다운받습니다.

## Floating Point Math in Solidity

이제 가격을 가져올 차례입니다. chainlink 문서의 코드를 리버스엔지니어링 해서 가져오는것도 좋습니다.

```solidity
// 사용자로부터 펀딩기금 받아오기
// 기금 인출하기
// 달러로 최소 펀딩 금액 설정하기

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract FundMe {

    uint256 public minimumUsd = 50;
    // uint256 public number;

    function fund() public payable {
        // 달러로 최소 금액을 설정하려 합니다.
        // 1. 어떻게 이 계약으로 ETH를 보낼까요?
        // number = 5;
        require(msg.value >= minimumUsd, unicode"최소 펀딩금액에 미달합니다.");
        // revert 될 경우 이후 액션에서 소모된 가스는 반환됩니다.
    }

    function getPrice() public {
        // ABI
        // Address 
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404)
        
    }

    function getVersion() public returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404)
        return priceFeed.version()
    }

    function getConversionRate() public {}
    // function withdraw(){}

}
```

이 코드는 해당주소의 계약이 AggregationV3Interface의 함수들을 가지고 있다는 가정 하에 작성한 코드입니다.

특히 latestRoundData 함수 안의 int256 answer 값이 현재 원하는 값입니다.

이제 priceFeed 에서 answer를 반환시켜봅시다.
```solidity
priceFeed.latestRoundData()
```

```solidity
function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}
```
여기서 latestRoundData 함수를 보면 한가지 값이 아닌 여러값을 반환함을 알 수 있습니다.

따라서 이렇게 작성해줍니다. (docs에도 주석으로 나와있습니다.)

```
(uint80 roundId, int price, uint startedAt, uint updateAt, uint80 answeredInRound) = priceFeed.latestRoundData();
```
하지만 지금은 int256 price만 필요하니 나머지는 지워도 상관없습니다.

```solidity
(,int256 price,,,) = priceFeed.latestRoundData();

```

msg.value 는 18자리 수입니다. 1ETH = 1000000000000000000 Wei

msg.value와 getPrice에서 받는 price값의 단위를 일치시켜주기 위한 작업을 해야합니다.
Wei는 0이 18개인 숫자이고,
현재 ether의 시세는 1800$ 이고 price에서 실제로  받는값은 소수점 없이 180000000000이므로 1800.00000000으로 생각하면 이미 0을 8개를 갖고 있으니  ether도 0이 18개 되도록 `10**10`을 곱해주거나 `10e10`을 곱해줘서 단위를 맞춰주면 됩니다.

`return price * 1e10;`

또한 int도 uint로 변환해줍니다. 타입케이스를 바꾸는 건 어렵지만 int와 uint는 쉽게 바꾸기가 가능합니다.

`return uint256(price * 1e10);`

```solidity
    function getPrice() public view returns(uint256) {
        // ABI
        // Address 
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404);
        // (uint80 roundId, int price, uint startedAt, uint updateAt, uint80 answeredInRound) = priceFeed.latestRoundData();
        (, int256 price, , , ) = priceFeed.latestRoundData();
        // ETH in term of USD
        // 1800.00000000
        return uint256(price * 1e10); // * 1 ** 10;
    }
```
마지막으로 함수에 view 속성을 추가해줍니다.

이제 getConversionRate 함수를 작성해보겠습니다.

```solidity
    function getConversionRate(uint256 ethAmount) public view returns(uint256) {
        
    }
```

파라미터로 들어오는 ethAmout 값이 USD로 얼마의 가치를 가지는지 계산해줘야 합니다.

먼저 위에서 만든 getPrice함수로 현재 1이더리움에 몇 달러인지 시세값을 ethPrice에 할당합니다.

두번째로 현재 시세값에 인수로 받은 이더리움 양(ethAmount)을 곱하여 총 인수로 받은 이더리움이 몇달러인지 계산합니다.

주의할 점은, ethPrice는 18자리 숫자이기 때문에 ethPrice 에 ethAmount를 먼저 곱한 뒤 다시 1**18로 나누어줘야 달러 소숫점에 맞출 수 있습니다.

예를 들어 1ETH 당 1800$ 일때 ethPrice는 `1800 * 1e18` 값을 가지고 ethAmount로 `2`가 들어왔다고 가정하면, `(1800 * 1e18) * 2` 가 되어 `3600 * 1e18`이 됩니다. 여기서 필요없는 소숫점을 제거하기 위해 `(3600 * 1e18) / 1e18`을 하면 `3600`$ 값을 얻을 수 있습니다.

참고로 곱셈을 먼저 하는 이유는 솔리디티 특성상 소숫점계산이 제대로 작동하지 않기 때문입니다.

솔리디티에서 소숫점계산을 하지 않는이유는 예를들어 ETH/USD 비율이 3이 나와야 할때 2999.999999999999999999 로 나오기 때문입니다.

하지만 소숫점 없이 전체 숫자로 계산할 경우엔 올바른 결과값이 나옵니다. 따라서 먼저 곱셉으로 소숫점을 생성하지 않고 결과값을 낸 뒤 자릿수로 나눠줘야 정상적인 결과를 얻을 수 있습니다.

```solidity
function getConversionRate(uint256 ethAmount) public view returns(uint256) {
    uint256 ethPrice = getPrice();
    uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;
}
```
또한 최소펀딩금액인 minmumUsd 변수에도 변환된 msg.value값과 같은 자릿수를 가질 수 있도록 1e18을 곱해줍니다.

`int256 public miniumbUsd = 50 * 1e18;`

배포후 fund 함수를 실행시킬때 VALUE 값에 들어갈 유효한 값을 알아내기 위해선 먼저 이더리움 시세를 확인 한 후에 최소펀딩금액 / 이더리움 달러시세 로 나누면 나누면 몇 eth를 보내야 하는지 알아낼 수 있습니다.
여기선 최소펀딩금액 50이고, 현재 시세를 1이더리움당 1800달러라 가정할시  50 / 1800 = 0.02777777777777777777777777777778eth 이상 보내야 유효한 VALUE 값이 된다는 걸 알 수 있습니다.

이더리움 컨버터로 Wei로 바꾼다면 27777777777777777Wei 이상의 VALUE값이 필요합니다.

반올림 하여 0.03으로 하여 30000000000000000 Wei를 넣어보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20230705.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20230807.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20230845.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20231150.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20231209.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20231338.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-05%20231405.png)


## Basic Solidity Arrays & Structs 2

FundMe 계약에서 다음으로 할일은 뭐가 있을까요?

계속 돈을 보낸 모든 사람들을 지속적으로 추적하게 만들겁니다.

이를 위해서 데이터 스트럭쳐를 하나 만들어보겠습니다.

주소를 담은 배열 `funders` 만들겠습니다.
그리고 이 안에 송금한 사람들의 주소를 계속 추가할겁니다.

```
address[] public funders;

function fund() public payable {
    require(getConversionRate(msg.value) >= minimumUsd, unicode"최소금액에 미달합니다");
    funders.push(msg.sender)
}

```
`msg.sender`는 `msg.value`와 같이 미리 정해진 솔리디티의 전역변수로 msg.value가 보내는 이더리움이나 화폐값의 양을 나타낸다면 sender는 보내는 사람의 `address`에 접근 할 수 있습니다. (예를 들어 보내는 사람의 메타마스크 계정 지갑주소와 동일합니다)

그리고 매핑을 이용하여 주소와 금액을 매핑해 어떤사람이 얼만큼 금액을 보냈는지도 만들 수 있을겁니다.

```
address[] public funders;
mapping(address => int256) public addressToAmountFunded;

function fund() public payable {
    require(getConversionRate(msg.value) >= minimumUsd, unicode"최소금액에 미달합니다");
    funders.push(msg.sender);
    addressToAmountFunded[msg.sender] = msg.value;
}

```

## Review Interfaces, GitHub Imports, & Math in Solidity

## Library

https://solidity-by-example.org/library/

라이브러리는 계약과 비슷하지만 상태변수를 선언할 수 없고 이더리움을 전송할수도 없습니다.

모든 라이브러리 함수가 내부(internal)인 경우 라이브러리가 계약에 내장됩니다(embedded).

그렇지 않으면 라이브러리를 배포한 다음 계약을 배포하기 전에 연결해야 합니다.

이 말이 무슨 뜻일까요?

우리가 원하는 함수를 만들어 다른 함수에 포함시킬 수 있다는 뜻입니다.

예를 들어, getConversionRate 함수를 기본전역변수인 msg.value에 포함시켜 msg.value.getConversionRate();처럼 사용이 가능하단 뜻입니다.

그럼 어떻게 하면 될까요?

일단 contract폴더에 새로운 파일을 만들어보겠습니다.
`PriceConverter.sol`

라이브러리는 스마트 계약 작성과 매우매우 유사합니다.

이번에도 SPDX라이센스 식별자로 시작합니다.
pragma 로 솔리디티 버전을 정해준 뒤 contract 대신 library 키워드를 사용하여 PriceConveter 라이브러리를 만들어줍니다.

```
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library PriceConverter {
    
}

```
라이브러리는 상태변수를 선언할 수 없고 이더리움도 보낼 수 없습니다. 또한 모든 함수는 internal 이 될 것입니다.

다음은 FundMe에 있는 Fund를 제외한 get으로 시작하는 모든 함수들을 PriceConverter로 잘라내어 붙여넣습니다.

또한 AggregatorV3Interface 도 FundMe엔 더이상 필요없고 여기서 사용할것이기 때문에 가져옵니다.

이 상태에서 컴파일을 하면 컴파일을 통과합니다.

이제 uint256인 값으로 msg.vlaue를 conversionRate 한 값을 직접 얻고싶습니다.

먼저 모든 함수를 public에서 internal로 전환합니다.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

library PriceConverter {
        function getDecimals() internal view returns (uint8) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404);
        return priceFeed.decimals();
        // 18 decimals
    }

    function getPrice() internal view returns(uint256) {
        // ABI
        // Address 
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404);
        // (uint80 roundId, int price, uint startedAt, uint updateAt, uint80 answeredInRound) = priceFeed.latestRoundData();
        (, int256 price, , , ) = priceFeed.latestRoundData();
        // ETH in term of USD
        // 1800.00000000
        return uint256(price * 1e10); // * 1 ** 10;
    }

    function getVersion() internal view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xECe365B379E1dD183B20fc5f022230C044d51404);
        return priceFeed.version();
    }

    function getConversionRate(uint256 ethAmount) internal view returns(uint256) {
        uint256 ethPrice = getPrice();
        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;
        // 2999.999999999999999999
        return ethAmountInUsd;
    }
    // function withdraw(){}
}

```

이제 이 모든 함수들을 FundMe.sol 에서 import 한 후 uint256 안에 함수로 붙여넣을 수 있습니다.

```solidity

import "./PriceConverter.sol"

contract FundMe {
    using PriceConverter for uint256;

    ...
    ...

```

이러면 FundMe에선 getConversionRate 함수가 정의되어 있지 않다고 에러를 발생시킵니다.

일단 라이브러리로 돌아와서 getConversionRate함수를 살펴보겠습니다.

Now in our library, the first variable that gets passed to the function is going to be the object that it's called on itself.
라이브러리에서 함수에 첫번째로 전달되는 인수는 함수가 스스로를 호출하는 객체가 될 것입니다.

따라서 암묵적으로 msg.value.getConversionRate()는 getConversionRate(msg.value)와 동일합니다.

```solidity
 function fund() public payable {
        require(msg.value.getConversionRate() >= minimumUsd, unicode"최소 펀딩금액에 미달합니다.");

        funders.push(msg.sender);
        addressToAmountFunded[msg.sender] = msg.value;
    }

```
다시 한번 살펴봅시다.
`msg.value.getConversionRate()`는 파라미터로 값을 전달하지 않았음에도 불구하고 값을 유추하고 있습니다. 왜냐하면 
`msg.value.getConversionRate()`에서 `msg.value`는 첫번째 파라미터로 취급되며 이와 같은 라이브러리 함수의 첫번째 파라미터로 취급됩니다.

만약 라이브러리 함수 getConversionRate에 다른 인수를 추가하고 싶다면 예를들어
```solidity
function getConversionRate(int256 ethAmount, int256 sometingElse) internal view returns(uint256){}
```
이라면

```solidity
require(msg.value.getConversionRate(123), unicode"....)
```
이런식으로 인수를 추가해줘야 합니다.

## SafeMath, Overflow Checking, and the "unchecked" keyword

솔리디티의 오랫동안 사용되던 라이브러리 중 하나는 SafeMath.sol입니다. 아마 다른 곳에서도 본적이 있을 수도 있습니다.

잠시 옆길로 새서 SafeMath에 대해 알아봅시다.

Contract 폴더에 SafeMathTest.sol 파일을 생성합니다.

SafeMath는 솔리디티 버전 0.8 이전부터 거의 모든 부분에 사용되어져 왔습니다. 지금은 거의 컨트렉트가 아니기도 합니다. 무슨 일이 일어난 걸까요? 왜 SfaeMath가 더이상 사용되지 않을까요? 예시코드를 한번 작성해보겠습니다.

0.8 이전 버전을 사용하는 솔리디티 계약을 만듭니다.

`uint8`의 최대값은 `255`입니다.

만약 여기에 +1을 더하면 어떻게 될까요?

```solidity
//SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract SafeMathTester {
    uint8 public bigNumber = 255; //uint8 -> maximum 255

    function add() public {
        bigNumber = bigNumber + 1;
    }
}
```
bigNumber를 그냥 호출해보면 255가 정상적으로 반환됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-06%20112023.png)

add를 호출해 bigNumber에 1을 더하면 bigNumber는 `0`으로 초기화 되어버립니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-06%20112044.png)

0.8.0 버전 이전에 uint와 int는 "unchecked"라는 개념으로 실행되어져왔습니다.

이말은 만약 숫자의 최대한계를 넘는 숫자를 전달하면, 0으로 전체를 감싸고 0부터 다시 수를 세기 시작하게됩니다. 이로써 유명해진 라이브러리가 바로 SafeMath입니다. 기본적으로 이 라이브러리는 최대수가 넘어가게되면 트랜잭션이 실패할 것이라고 미리 경고해주는 식으로 작동합니다.

이제 0.8.0 버전으로 컴파일 해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-06%20112844.png)

add를 호출하게 되면 에러가 발생합니다.

0.8.0 버전부터는 overflow와 underflow 가 변수에서 일어나면 미리 체크하도록 만들었습니다. 

unchecked 키워드를 사용한다면 unchecked 버전으로 되돌릴 수도 있습니다.

```solidity
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeMathTester {
    uint8 public bigNumber = 255; //uint8 -> maximum 255

    function add() public {
        unchecked {bigNumber = bigNumber + 1;}
    }
}
```
오버플로우를 일으켰지만 에러발생대신 0으로 돌아가게 됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-06%20113607.png)

즉 0.7.6 버전 이하에서 보는 코드는 위 코드와 동일하다 보면 됩니다.

언뜻보면 unchecked 키워드가 필요없을 것 처럼 보이지만, 가스사용을 효율적으로 조절할때 사용됩니다.

이제 FundMe 계약으로 돌아가보겠습니다.

## Basic Solidity For Loop

이제 모인 자금을 인출하는 함수 withdraw를 만들어보겠습니다.

모든 자금을 빼간다면 funder 배열과 addressToAmountFunded 매핑이 초기화되어야 합니다.

각각의 funder로 부터 돈을 인출할것이기 때문에

여기서 for loop에 대해 알아보겠습니다.

/* */ 안에 있는 모든 구문은 주석으로 처리됩니다.

```solidity
for(/* starting index, ending index, step amount*/) {
    //code
}
```

```solidity
function withdraw() public {
    for(int256 funderIndex = 0; funderIndex < funders.length; funderIndex++) {
        address funder = funders[funderIndex];
        addressToAmountFunded[funder] = 0;
    }
}
```
이제 출금과 동시에 펀딩한 사람 객체를 배열(funders)에서 삭제해야 할 것입니다. 
또한 실제로 출금하는 코드를 작성해야합니다.

사용자 배열을 초기화 시키는 방법은 사용자 배열마다 0으로 초기화시켜주거나 아니면 이 배열 전체를 초기화 시켜주는 방법 2가지가 있습니다.

## Basic Solidity Resetting an Array

for 로 일일이 루프하는기보다 array를 초기화시켜보겠습니다.

```solidity
funders = new address[](0);
```
funders는 새로운 address를 가진 []배열입니다 안에는 (0)개의 오브젝트가 들어있습니다.(아무것도 없습니다.) 

## Sending ETH from a Contract

이제 이 함수를 부른 사람에게 돈을 전달해줄 코드를 작성해야합니다.

이더리움을 보내거나 기타 네이티브 블록체인 통화를 보낼때 , 3가지의 다른 방법이 있습니다. 이 세가지 방법을 다 배워볼 것입니다. 그리고 세가지 사이의 차이점에 대해서 말해볼 것입니다. 
1. transfer
2. send
3. call

### 1. transfer : 
transfer는 가장 단순하고 쉬운 방법으로 
합리적인 방법입니다.

msg.sender 로 해당 전송자 변수를 불러온 뒤 transfer를 사용합니다 transfer 안에는 금액을 넣어야합니다.

this는 현재의 전체 컨트렉트(FundMe)를 가리킵니다.

address(this)로 FundMe에 접근하여 balance 변수에 접근하면 계약이 가지고 있는 금액을 참조할 수 있습니다.

이를 위해 먼저 해야할 일은 이 msg.sender를 address에서 payable로 타입캐스트(타입변환) 해주는 것입니다.

```solidity
// msg.sender = address
// payable(msg.sender) = payable address
payable(msg.sender).transfer(address(this).balance)
```
솔리디티에서 입출금을 위해선 반드시 payable 키워드를 붙여야합니다. 그래서 payable 타입캐스터로 msg.sender를 감싸준것입니다.

하지만 transfer에 문제점이 좀 있습니다.

https://solidity-by-example.org/setting-ether/

첫부분에서 MetaMask로 Account1에서 계정2로 ETH를 전송할때 21000가스가 들었습니다.

transfer 함수는 23000가스로 제한이 걸려있습니다.
만약 초과해서 사용한다면 에러를 발생시킵니다.

### 2. send

다음에 사용해볼것은 send입니다.
send는 transfer와 마찬가지로 23000의 가스사용량이 제한되어있습니다. 만약 실패한다면 boolean 를 반환합니다.

따라서 transfer 함수는 실패한다면 에러를 일으키고 트랜잭션을 되돌릴것입니다.

send를 이용한다면 에러를 발생시키지 않습니다. 성공했는지 여부를 알리는 boolean을 반환합니다.

```solidity
payable(msg.sender).send(address(this).balance);
```
그런데 만약 이렇게 끝나게 된다면 send는 트랜잭션을 되돌리지(revert) 않기때문에 우리가 돈을 돌려받을 코드를 작성할 필요가 있습니다.

```solidity
boolean sendSuccess = payable(msg.sender).send(address(this).balance);
require(sendSuccess, "Send failed");
```
이렇게 작성한다면 require가 이전행동을 되돌림으로서 sendSuccess 트랜잭션이 revert할 수 있게 됩니다.

따라서 transfer는 자동으로 에러와 트랜잭션을 반화하고, send는 require문을 작성했을때만 에러와 트랜잭션을 반환합니다.

세번째는 무엇일까요?

### 3. call

세번째는 `call`입니다.

`call`은 우리가 처음으로 배우는 솔리디티에서 실제 사용되는 저수준 명령어 일겁니다. 이 call 함수는 매우 강력합니다.

call은 이더리움의 모든 함수를 virtually 로 사용할 수 있습니다. 그것도 API 없이도 말이죠. 이 call에 대해 후에 심화해서 알아볼 것입니다. 지금은 이것을 이용해서 이더리움을 보내는 방법만 알아보겠습니다.

콜은 'send'와 매우 비슷해보입니다.

```solidity
payable(msg.sender).call()
```

여기서 call() 의 괄호 안에 어떤 함수정보나 다른 계약에서 불러올 함수에 대한 정보를 넣어줄 수 있습니다.

여기서는 실제로 함수를 불러들일 필요는 없기때문에 공백으로`("")` 놔둘겁니다. 이렇게 함으로써 트랜잭션을 하는것처럼 이용할 수 있습니다.

```solidity
payable(msg.sender).call("");
```

그리고 배포탭을 보면 항상 'msg.value' 값이 있습니다(Remix의 DEPOLY탭의 VALUE 인풋). 이 call 함수를 일반 트랜잭션처럼 사용할 것이며 'msg.value'와 같은 기능을 추가할 수 있습니다.

```solidity
payable(msg.sender).call{value: address(this).balnace}("");
```


This call function actually returns two variables.
And when a function returns two variables, we can show that by placing them into parentheses on the left hand side. 

The two variables, it returns are going to be a Boolean, that we're going to  call call success.

이 call 함수는 실제로 두개의 변수를 반환합니다. 그리고 이를 좌변항의 괄호안에 놓았을때 그 두 변수를 나타낼 수 있습니다.

```solidity
() = payable(msg.sender).call{value: address(this).balance}("");
```

이 두변수들은, 하나는 boolean을 변환할것이며, 이걸 callSuccess라 지정하겠습니다. 그리고 다른 하나는 bytes를 반환할것이며, dataReturned라 지정하겠습니다.

```solidity
(bool callSuccess, bytes dataReturned) = payable(msg.sender).call{value: address(this).balance}("");
```

call은 다른 함수를 호출 할 수 있도록 해줍니다. 만약 호출한 함수가 데이터나 값을 반환한다면, 우리는 그걸 dataReturned 변수에 할당할 것입니다. 또한 call은 함수가 성공적으로 호출되었는지 호출 성공여부를 반환하며, 성공했다면 true 아니라면 false를 반환합니다. 이 boolean은 callSuccess에 할당할 것입니다.

그리고 bytes객체는 배열이기 때문에 데이터 반환은 memory 안에 있어야 합니다.

```solidity
(bool callSuccess, bytes memory dataReturned) = payable(msg.sender).call{value: address(this).balance}("");
```

사실 여기서는 아무함수도 불러오지 않았기 때문에 데이터를 반환하지 않았고, 그렇기 때문에 dataReturned에는 신경쓸필요가 없습니다.

price 계약과 비슷하게 dataReturned 부분을 지우고 진행해도 상관없고, 다만 콤마(,)는 놔두어서, 솔리디티에게 "이 함수가 두개의 변수를 반환한다는걸 알아, 하지만 한개만 사용할거야" 라고 알려줘야 합니다.

그리고 send와 마찬가지로 require문을 작성해줘야합니다.

```solidity
(bool callSuccess, bytes dataReturned) = payable(msg.sender).call{value: address(this).balance}("");
require(callSuccess, "Call failed");
```

이 문의 뜻은 callSuccess 를 필요로하고(require) 만약 없다면(false) "Call failed"라는 에러메세지와 함께 revert 시킵니다.

현재 기준으로는 이더리움이나 블록체인 화폐를 보내거나 받을때 `call`을 사용하는 것이 권장되는 방식입니다.

## Basic Solidity Constructor

문제가 하나 있습니다. 지금 상태에선 누구나 withdraw함수로 돈을 빼갈 수 있다는 겁니다.

이 계약의 소유자만이 출금할 수 있도록 하려면 어떻게 해야할까요? 몇몇 함수들을 세팅해보겠습니다.

배포시에 배포자가 이 계약의 소유자 될 수 있도록 자동으로 설정하게 만들겁니다.

```solidity
    function callMeRgihtAway() {
        
    }
```
계약이 배포되면 해당함수가 작동하면서 배포자를 자동으로 계약 소유자로 변경할 것입니다.

이 과정에서 두번의 트랜잭션이 필요할겁니다.
그리고 이런 방식으로 코드를 짜려면 굉장히 불편할 겁니다.

그래서 대신에 솔리디티는 constructor라는 것이 있습니다.

만약 다른 프로그램 언어에 익숙하다면, constructor는 다른 언어에 있는 constructor와 역할이 같습니다.

constructor는 이 계약이 배포되는 즉시 호출되는 함수입니다.

만약 이렇게 작성한다면

```solidity
constructor() {
    minimumUsd = 2;
}
```

minimumUsd는 50 * 10e18 값이 아닌 즉시 2로 변경됩니다.

왜냐하면 constructor이 호출되는 트랜잭션은 이 계약이 생성되는 트랜잭션과 같기 때문입니다.

constructor는 입맛에 따라 계약을 설정 할 수 있기 때문에 매우 유용합니다. 예를들어

withdraw 함수를 오직 이 계약의 소유자만 사용가능하게 만드려면, 컨스트럭터가 계약의 소유자가 누구인지 결정하게 만들면 됩니다.
전역변수로 owner 주소를 만듭니다.

```
address public owner;
```

이제 컨스트럭터에 다음과 같이 작성합니다.

```solidity
address public owner;

constructor () {
    owner = msg.sender;
}
```
컨스트럭터 안의 msg.sender는 이 계약의 배포자를 가르킵니다.

이제 owner에 계약배포자의 주소가 들어가게되었습니다.

## Basic Solidity Modifiers

소유자(owner)가 설정되었으니 이제 withdraw 함수를 소유자만 사용할 수 있도록 설정해보겠습니다.

withdraw 함수안의 내용을 실행시키기 전에 맨 위쪽에 requrie문을 작성합니다.

withdraw 함수를 작동시키는 사람 (msg.sender)가 owner와 같은지 확인하고 다음 코드를 실행시킬 수 있도록 작성합니다.

```solidity
function withdraw() public {
    require(msg.sender == owner, unicode"펀딩 소유자가 아닙니다.");
    for(uint256 fundersIndex = 0; fundersindex < funders.length; fundersIndex++) {
        address funder = funders[fundersIndex];
        addressAmountToFunded[funder] = 0;
    }
    funders = new address[](0);
    (bool callSuccess,) = payable(msg.sender).call{value: address(this).balance}("");
    require(callSuccess, unicode"호출 실패");
}
```

그런데 매번 함수마다 이렇게 require문을 작성하기 번거로울 겁니다. 그래서 필요한게 `modifier`입니다.

이번에는 require문 대신에 modifier를 사용해 작성해보겠습니다.

모디파이어는 함수선언문 오른쪽에 키워드로 사용할 수 있습니다. 그 기능으로 함수를 수정할 수 있게 할 것입니다.

modifier 키워드로 onlyOwner 라는 객체를 생성하고 앞서 withdraw함수에서 작성한 소유자 확인 require문을 붙여넣습니다. 그 후 맨 끝줄에 `_`(언더스코어)를 붙입니다.

```solidity
    modifier onlyOwner {
        require(msg.sender == owner, unicode"펀딩 소유자만 인출할 수 있습니다.");
        _;
    }
```

그러고나서 midifier를 함수선언문 오른쪽에 붙여줍니다

```solidity
    function withdraw() public onlyOwner {
        for(uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++) {
            address funder = funders[funderIndex];
            addressToAmountFunded[funder] = 0;
        }
        // reset the array
        funders = new address[](0);
        // actually withdraw the funds
        (bool callSuccess,/*bytes dataReturned*/) = payable(msg.sender).call{value: address(this).balance}("");
        require(callSuccess, unicode"호출 실패");
    }
```

그렇다면 모디파이어에서 어떤 일이 일어나는 걸까요?

withdraw 함수에 onlyowner 모디파이어를 붙이면 솔리디티에게 이렇게 말하는 것입니다.

"withdraw 함수에서 withdraw 안의 코드를 읽기 전에 modifier onlyOnwer 코드를 먼저 보렴, 그리고 그곳에 있는걸 무조건 먼저 실행하고, `_;`로 가렴. "

`_`가 의마하는 것은 나머지 코드들을 실행하라는 뜻입니다.

정확히 말해서 withdraw 함수가 실행되면 onlyOnwer 에 있는 코드가 먼저 실행되고, withdraw의 나머지 코드가 실행되는 겁니다. 

만약 `_`가 위쪽에 와있다면

```
modifier onlyOwner {
    _;
    require(msg.sender == owner, unicode"펀딩 소유자만 인출할 수 있습니다.");;
}
```

이렇게 되면 withdraw의 나머지 코드들을 먼저 실행시킨뒤 onlyOnwer의 require문을 실행시키게 됩니다.

## Testnet Demo

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-06%20234653.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-06%20234833.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-06%20235036.png)

자릿수를 맞추기위해 minimumUsd에 1e18을 곱해준 값이 나옵니다.

owner는 이 컨트렉트 소유자의 address입니다. (constructor 안에서 호출한 msg.sender 값)

addressToAmountFunded 와 funders 는 아직 아무도 fund하지 않았으므로 0입니다.

그리고 블록체인의 상태를 변경할 수 있는 빨간 버튼과 주황색 버튼을 확인 할 수 있습니다.

withdraw는 주황색입니다. 왜냐하면 이더리움을 사용하지도 않고 받지도 않기 때문입니다.

fund는 빨간색입니다. fund는 payable 함수이고 이더리움을 전송 할 것입니다.

이제 이 계약을 사용해보겠습니다.

50 / 1900(현재이더리움시세) = 0.0263157894736842

이를 wei로 환산합니다. * 1e18 = 26315789473684200

올림하여 27000000000000000 를 VALUE 값에 넣어 보내겠습니다.

성공하면 etherscan에서 해당 트랜잭션을 확인 할 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20001510.png)

트랜잭션에서 해당 컨트렉트 정보 페이지로 넘어가보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20001619.png)

컨트렉트 정보를 보면 두개의 트랜잭션이 발생한 걸 확인 할 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20001650.png)

하나는 컨트렉트 크리에이션(컨트렉트를 생성했을때) 트랜잭션이고

다른 하나는 Fund 함수를 호출했을때의 트랜잭션입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20001751.png)

또한 Balance 를 확인하면 0.027 Ether 가 들어와있습니다.

Fund 를 호출할때 VALUE에 넣었던 ether 값이 그대로 적용되었습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20001910.png)

확인을 위해 한번 더 송금하고 0.054 Ether 가 되는지 확인해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20002409.png)

Fund 메소드가 한번 더 호출되었고 자산도 예상치에 부합하는 0.054Ether로 늘어났습니다.

이제 addressToAmountFunded 와 funders를 확인해보겠습니다.

addressToAmoutFunded 에 Fund한 지갑주소를 복사해서 넣습니다.

funders에도 0과 1을 각각 넣고 호출해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20002606.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20002754.png)

이제 withdraw 함수가 작동하는지 확인해보겠습니다.

먼저 withdraw가 소유자만 작동시킬 수 있는지 확인합니다.

메타마스크 계정을 계정2로 바꾸고 withdraw 함수를 호출해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003242.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003302.png)

계약 소유자가 아닐경우 withdraw 트랜잭션이 revert 되는 모습을 볼 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003327.png)

이제 다시 소유주 계정으로 withdraw를 실행시켜보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003447.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003620.png)

이번엔 정상적으로 작동합니다.
계약의 자산도 0으로 바뀌었습니다.

그리고 addressToAmountFunded는 0을 반환하고 funders 는 execution revert 됩니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003653.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003815.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20003822.png)

## Advanced Solidity Concepts 5:04:30

### Advancded Solidity Immutable & Constant 5:05:40

이제 이 펀딩 계약을 더 전문적으로 만들어보겠습니다.
대단하다고는 할 수 없지만 좀 더 나아질 거에요. 왜 그런지 알게될 겁니다.

먼저 이쪽의 변수들을 살펴보겠습니다.

특히 owner 와 minimunUsd를 보면, owner는 계약에서 단 한번만 설정되었고, 그 후 전혀 값이 바뀌지 않았습니다.
minimumUsd는 한번만 설정되었고, 심지어 constructor 바깥에서 선언되었습니다. 

만약 우리가 단 한번만 값이 설정되는 변수를 가지고 있다면, 솔리디티에 있는 툴을 이용해서 가스를 효율적으로 사용하도록 만들 수 있습니다.

일단 FundMe를 컴파일하고 JS VM에 배포해보겠습니다.
참고로 VM에 배포할 경우 fund 와 withdraw 등은 사용하지 못할 겁니다. 왜냐하면 VM에 chainlink network가 없기 때문입니다.(chainlink는 실제 서비스이기때문에 실제 메인넷이나 테스트넷에서 작동가능)

하지만 상관없습니다. 여기서 중요한건 가스사용량 입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20095118.png)

현재 이 계약은 872,573 가스가 사용되었고, 이 사용량을 줄이기 위해 몇가지 트릭을 추가하겠습니다.

트릭에 사용할 수 있는 키워드는 2가지가 있습니다.
1. constant
2. immutable

솔리디티에는 변수를 재할당 할 수 없게 만드는 2가지 키워드가 있습니다. 

솔리디티 공식문서에서 더 자세히 알 수 있습니다.

https://docs.soliditylang.org/en/v0.8.14/contracts.html?highlight=constant#constant

https://docs.soliditylang.org/en/v0.8.14/contracts.html?highlight=constant#immutable

만약 변수가 함수 바깥에서 한번만 할당되었고, 이후에 재할당이 이루어지지 않았다면, 그래서 만약 변수가 컴파일 시 할당되었다면, 변수에 `constant` 키워드를 추가할 수 있습니다. 

```solidity
uint256 public constant minimumUsd= 50 * 10e18;
```

나중에 stroage에 대해서 좀 더 배우겠지만, constant 키워드를 추가하면, minimumUsd는 스토리지 공간을 차지 하지 않고, 읽기도 훨씬 쉬워집니다. 

컴파일 후 배포해보겠습니다. 가스가 줄어들었는지 확인합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20104528.png)


872,573 -> 852,990 로 줄어든걸 확인 할 수 있습니다.
20000 정도의 가스를 아낄 수 있습니다. 이 정도면 이더리움을 한번 보낼 수 있을 정도의 가스입니다.

보통, constant 변수는 다른 명명규칙을 가지고 있습니다. 보통 모두 대문자로 표기하고 `_`로 단어를 나눕니다. 이렇게 하면 해당 명명규칙을 가진 변수가 상수(constant)라는 걸 알 수 있고 읽는 비용이 저렴하다는 걸 알 수 있습니다.

```solidity
int256 public constant MINIMUM_USD = 50 * 1e18;
```

다시 배포하고 이번엔 MINIMUM_USD를 호출해보겠습니다.
view 함수도 가스값을 가진다는 사실을 지난시간에 알아보았습니다. 

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20105504.png)

execution cost 를 확인해보니 
21415 gas 가 명시되어있습니다.

constant 키워드를 없이 deploy 하면 excution cost가 23515 gas 입니다.

23515 -> 21415 로 줄어들었습니다. 

이런 변화는 작은 트랜잭션에선 체감이 덜 될지도 모르지만 이더리움 같은 비싼체인에서는 큰 차이를 생깁니다. 

예를들어 이더리움에서 현재 가스요금(current gas price)를 알 수 있습니다.

https://etherscan.io/gastracker

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20110156.png)

이를 평균 42gwei 값을 wei로 환산해서 트랜잭션에 소모하는 가스량에 곱하면 소모하는 총 이더리움(가스요금)을 구할 수 있습니다.

21,415 * 42,000,000,000 = 899,430,000,000,000 wei

= 0.00089943 ether = 1.618974 달러

23,515 * 42,000,000,000 = 987,630,000,000,000 wei

= 0.00098763 ether = 1.777734 달러

물론, 아직 현재 배우는 단계에서 가스 최적화를 생각하지마십시오. 나중에 정어어엉말 잘 하게 된다면 그때 가스 최적화를 시작하면 됩니다. 하지만 지금 가스최적화에 시간을 뺏기거나 스트레스 받지 마세요!

이제 나머지 owner 변수를 살펴보겠습니다.
우리는 owner를 컨스트럭터 바깥에서 선언한 후, 컨스트럭터에서 한번 할당하고 바꾸지 않았습니다.

이렇게 컨스트럭터에서 할당하고, 컨스트럭터 바깥에서 선언한 변수는 `immutable` 키워드를 사용할 수 있습니다.

일반적으로 immutable 값을 나타내는 좋은 컨벤션은 이름앞에 `i_`를 붙이는 것입니다.
```solidity
address public immutable i_owner;
```
constant 키워드와 가스절약 방식이 비슷합니다. 

owner 변수는 `address public immutable i_owner;` 구간에서 값을 설정하지 못합니다. 왜냐하면 전역스코프에 는 실행되고 있는 함수가 없기 때문입니다. 즉 전역에서는 msg.sender를 호출하지 못합니다. msg.sender는 함수 안에 있어야 받을 수 있습니다. 

이제 immutable 유무에 따른 가스값을 알아보겠습니다.

immutable 미적용
![immutable 미적용](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20112311.png)

immutable 적용
![immutable 적용](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20112427.png)

23622 -> 21508

이 두가지 방법이 가스를 절약할 수 있는 방법은 스토리지에 이 변수를 저장하는것이 아니라 이 계약에 직접 byte코드로 들어가기 때문입니다. 이러한 저수준 컨트롤은 이 과정의 후반부에 배울것입니다.

### Advancde Solidity Custom Errors 5:12:56

가스 소모량을 줄일 다른 방법이 또 있을까요?

하나는 require를 업데이트 하는 것입니다.

현재 require문에는 에러메세지가 포함되어있는데 이 에러메세지 문자열 하나하나마다 배열에 포함되어야 하기 때문에 소모되는 비용이 있습니다.

0.8.4 버전부터 커스텀 에러 기능이 생겼습니다.
맨 위에 커스텀에러를 선언하고 rquire 대신 if를 사용하는 방법입니다.

https://blog.soliditylang.org/2021/04/21/custom-errors/

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized();

contract VendingMachine {
    address payable owner = payable(msg.sender);

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        owner.transfer(address(this).balance);
    }
    // ...
}
```
이 방법은 직접 에러코드를 호출하는 것(`error Unauthorized();`)으로 훨씬 가스량을 줄일 수 있습니다. 오류와 관련된 전체 문자열을 호출하는 것이 아니라 오류코드를 직접 호출하기 때문입니다.

require 문을 custom error로 바꿔보겠습니다.

먼저 contract 바깥에 error를 선언합니다.
```sol
error NotOwner();
```

이제 onlyOwner 모디파이어의 require문을 고쳐보겠습니다.

```sol
//require(msg.sender == i_owner, unicode"계정 소유자만 인출 가능합니다.")
if(msg.sender != i_owner) { revert NotOwner();}
_;
```

이렇게 하면 긴 오류메세지를 직접 저장해하는 대신 오류코드만 호출하면 끝납니다.

하지만 아직도 require 문을 많이 볼 수 있을겁니다. custom error 가 만들어지지 얼마 안됬기 때문에 상황에 따라 사용하는 걸 추천드립니다. 아마 미래에 custom error도 require 문 만큼 가독성이 좋게 업데이트 될 지도 모릅니다. 하지만 더 효율적인 가스사용을 원한다면 custom error를 사용하면 됩니다.

revert는 require에서 revert 되는 원리와 달리 revet 다음에 오는 아무것이나 다시 되돌릴 수 있습니다.

### Advancde Solidity Receive & fallback

자 이제 이 계약을 향상시켜줄 방법 한개만 더 봅시다.

떄때로, 사람들은 필요한 구문을 통과하지 않고 이더리움이나 블록체인 토큰을 가져가는 계약과 상호작용 할 것입니다.

예를 들어, remix의 JavaScript EVM에서 fund 함수 없이 돈을 보낼 수 도 있습니다. 그렇게 되면 어떻게 될까요?

fund함수를 실행시켰나요? 아닙니다. 우리는 기부자를(funder)를 추적하지 않을 것이고, 그 사람의 개인정보를 가지고 정보를 이 계약에 업데이트 하지 않을 겁니다.

그래서 나중에 우리가 보상이나 어떤걸 주고 싶을 때 우리는 그 기부자들에 대해 알 수 없습니다. 그리고 이건 문제가 될겁니다. 사람들이 우리에게 정보없이 돈을 보낼 것이고 우리는 그들에게 어떠한 보상을 줄 수도 없게 됩니다.

추가적으로 그 사람들이 아마 의도치 않게 다른 함수를 잘못 호출했을 수도 있습니다. 그리고 그들은 메타마스크를 사용하지도 않고, 그들에게 무언가 알려줄 툴도 사용하지 않을거고(이 트랜잭션이 잘못됬다는 걸 알려주는 ), 이런경우에 우리는 어떻게 대처해야 할까요?

fund 함수를 호출하지 않고 이 계약에 ETH를 보냈을때 어떤 일이 발생할까요?

지금은 fundMe 계약의 balnace로 ETH가 전송될 것이며 fundMe 계약은 보낸 사람을 추적하지 않을 겁니다.

하지만 사실 사람들이 존재하지 않는 함수를 호출해서 이 계약에 돈을 보냈을때도 코드를 작동시키는 방법이 있습니다.

자, 솔리디티엔 두가지 특별한 함수가 있습니다.

하나는 `receive` 라 불리고 다른 하나는 `fallback`이라 불립니다.

1. `receive()`
2. `fallback()`

솔리디티의 여러 특별 함수 중 두가지가 이것들입니다.

https://docs.soliditylang.org/en/v0.8.14/contracts.html?highlight=receive#receive-ether-function

https://docs.soliditylang.org/en/v0.8.14/contracts.html?highlight=receive#fallback-function

>A contract can have at most one receive function, declared using 'receive() external payable { ... }' (without the function keyword). This function cannot have arguments, cannot return anything and must have external visibility and payable state mutability. It can be virtual, can override and can have modifiers.

계약에는 `receive() external paybal { ... }`(`function` 키워드 없이)을 사용하여 선언된 최대 하나의 `receive` 함수를 가질 수 있습니다. 이 함수는 인수를 가질 수 없고, 아무것도 반환할 수 없으며, `external` 가시성(visibility) 및 `payable`지급 가능한' 상태 변이성(mutability)을 가져야 합니다. 가상(`virtual`)일 수 있고, 재정의(`override`)할 수 있으며, 수정자(`modifier`)가 있을 수 있습니다.

이게 정확히 의마하는 바가 뭘까요?

따로 파일을 만들어 실험해 보겠습니다.

FallbackExample.sol

```sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

contract FallbackExample {
    uint256 public result;

    receive() external payable {
        result = 1;
    }
}
```

솔리디티는 receive()가 특별함수임 알기에
이더리움을 이 계약으로 보내거나 트랜잭션이 일어났을때 트랜잭션과 연관된 코드가 없더라도receive 함수가 작동할 것입니다.

한번 자바스크립트 vm에 배포해서 테스트 해볼까요

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20135136.png)

처음 아무것도 보내거나 트랜잭션 하지 않았을대 result는 0으로 초기화 됩니다.

하지만 이 계약으로 이더리움을 조금 보내면 어떻게 될까요?

remix의 Low level interactions 에 CALLDATA에서 ETH를 직접적으로 보내보겠습니다. 지금 여기에 있는 calldata가 무엇인지 알지 못해도 괜찮습니다. 이곳을 통해 그냥 다른 함수를 이용해 작업하거나 보낼 수 있다는 사실만 알아두십시오. 

그리고 파라미터를 transact 옆 인풋에 넣어 보낼 수 있습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20135440.png)

이곳은 VM 환경이기 때문에 MetaMask를 사용 할 수 없습니다. 따라서 메타마스크에서 보내기(send)기능을 사용하는것과 동일한 방식을 통해 테스트할 겁니다.

VALUE 값에 1wei를 넣은 뒤 Low level interactions에 아무것도 넣지 않은 상태로 transact 버튼을 누릅니다. 이는 메타마스크의 send 작동과 비슷합니다.

우리가 receive 함수를 실행시키지도 않았는데
receive()를 실행시켰다고 로그에 나옵니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20135858.png)

그럼 result 값이 바뀌었는지 확인해볼까요

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20140023.png)

receive 안의 코드가 실행되어 result에 1을 재할당 하였습니다!

현재 배포를 지우고 다시 배포한 후 이번엔 0wei VALUE 로 transact 버튼을 눌러보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20140240.png)

마찬가지로 0을 보내더라도 receive 함수가 작동되어 1을 할당 한 것을 확인 할 수 있습니다.

receive 함수는 트랜잭션이 일어난 모든 순간에 작동됩니다. 그리고 여기에선 함수를 특정짓지 않고, call data도 빈 값으로 두었습니다.

FundMe와 같이 다른 계약과 같이 작동해야 할때는, 예를 들어, 우리는 fund,withdraw,addressToAmountFunded... 같은 함수들 중 하나를 작동시킬때 calldata에 이 함수 들 중 하나를 가리키는 특정 데이터를 채웁니다.

즉 receive는 calldata가 빈 값 일때 작동됩니다.

이번엔 calldata에 특정함수를 가리키는 값을 집어넣어 보겠습니다.

`0x00`을 입력했을때 'Fallback' function is not defined라고 에러 메세지가 나옵니다.

즉 calldata에 들어있는 함수정보를 통해 해당 함수에 맞는 함수를 실행하고, 만약 해당 함수를 찾지못햇을때 fallback 함수가 실행되는 겁니다.

```sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

contract FallbackExample {
    uint256 public result;

    receive() external payable {
        result = 1;
    }

    fallback() external payable {
        result = 2;
    }
}
```

fallback 은 솔리디티가 예상하는 함수 "키워드"를 입력하지 않았을때 실행됩니다.

이것과 비슷한 것이 지난시간에 배운것중에 있습니다. 바로 constructor()입니다. 이것 또한 특별함수입니다. 솔리디티가 constructor가 배포시에 가장 먼저 실행되어야 할 코드라는 걸 알고 있습니다.

이제 코드로 돌아와서 다시 배포한 후에 `0x00`값을 넣고 Transact를 눌러봅시다. 그럼 솔리디티가 해당하는 함수를 찾지 못하고 `fallback`함수를 실행시키게 되고 result는 2값을 반환하게 됩니다.

이번엔 다시 calldata에 아무것도 넣지 않고 transact  버튼을 눌러봅시다. 이는 솔리디티가 이렇게 받아들이게 됩니다 " 이 계약에 이더리움을 보내거나 함수를 호출하기 하려하는데, 어떤 일을 할지 특정짓지 않고 그것을 하려하는구나, 내게 준비된 (레시피) 함수가 있으니 그걸 실행시켜줄께 " 이렇게하여 `receive` 함수를 실행시키게 되고 result 값은 다시 1이 됩니다.

https://solidity-by-example.org/fallback/

```
이더리움이 계약으로 전송됨
            |
     msg.data 가 비었나요?
          /   \
         네   아니오
        /        \
    receive()?  fallback()
      /  \
    네   아니오
    /       \
receive()  fallback()
```

이제 FundMe에 적용시켜 보겠습니다.

fund 함수를 작동시키지 않고 돈을 보내거나 트랜잭션 했을때 receive와 fallback을 실행시키도록 만들겁니다.

누군가 의도치 않게 돈을 보냈을때, receive 함수가 작동되도록 그리고 fallback함수가 작동되도록 해서 자동적으로 fund 함수를 실행시키도록 합니다.

```sol
receive() external payable {
    fund();
}

fallback() external payalbe {
    fund();
}

```

이제 실제 테스트넷에 배포해서 작동되는지 확인해보겠습니다.

배포가 완료되면 fund함수를 사용하지 않고 메타마스크를 직접 열어 보내기(send) 기능에 해당 계약주소를 넣고 ETH를 송금합니다.

현재 배포된 계약의 상태는 계약생성시 트랜잭션밖에 없고 balance도 0ETH 인 상태입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20144400.png)

abc3

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20144502.png)

abc2

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20144636.png)

abc1

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20144700.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20144720.png)

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20144740.png)


이제 이더스캔에 업데이트된 정보를 확인해보겠습니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20145044.png)

계약에 돈이 들어와있고 fund 대신 transfer로 트랜잭션도 발생했습니다.

이제 funders 배열도 확인해봅시다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20145219.png)

배열에도 우리가 보낸 지갑주소가 저장되어있으며 해당 지갑주소로 addressToAmoutFunded를 호출하면 보낸 금액을 확인할 수 있습니다.

## LESSON 4 Recap

### 아직 안배운 것들
실제 사용하는 이유를 모르면 배우기 어렵기 때문에 나중에 배울것입니다.

1. Enums
2. Events
3. Try / Catch
4. Function Selectors
5. abi.encode / decode
6. Hasing
7. Yul / Assumbly

하지만 그래도 지금까지 배운것들로만으로도 대부분의 솔리디티 코드가 무엇을 하는지 이해할 수 있을 겁니다.

### LESSON4에서 배운것들
1. 솔리디티의 특별한 함수
 - receive
 - fallback
 - constructor

이 함수들은 function 키워드 없이 사용 할 수 있습니다.
msg.data에 있는 값이 특정 함수를 지정하는 값이 아니라면 fallback 함수를 실행시킵니다. msg.data에 값이 비어있다면(empty) receive함수를 실행시킵니다.
 
2. 가스를 아낄 수 있는 두가지 키워드
 - constant
 - immutable

 constant와 immutable은 오직 한번만 업데이트 되는 변수에만 적용 할 수 있습니다. 
 constant는 한번만 할당되었고, 이후에 값이 변경되지 않는 경우 사용가능하고, immutable은 constructor에서 할당되어 이후에 값이 변경되지 않는 변수에 사용합니다.

3. remix의 Low level Interactions 는 CALLDATA 와 transfer를 통해 함수호출 없이 값을 보낼 수 있으며 CALLDATA가 비어있을땐 `receive` 함수를 호출하고 CALLDATA에 값이 있다면 값이 가리키는 특정 함수를 찾아 실행시키고 만약 없다면 `fallback`함수를 실행시킵니다. 

# 축하합니다! 솔리디티 기본과정을 마쳤습니다! 5:30:40
![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20151022.png)

# LESSON 5 Ethers.js Simple Stroage

## Effective Debugging Strategies & Getting Help Don't skip this!!

하드햇(HardHat)과 자바스크립트로 넘어가기 전에 왜 그래야하는지 알아야합니다.

잠시 도움을 요청하는 방법과 문제에 대응하는 방법에 대해 알아봅시다.

- tinker and figure out yourself : Limit tinkering / triaging to 20 minutes.

20분이 넘어간다면 다음 단계로 넘어가세요.
하지만 반드시 적어도 15분은 스스로 생각해보세요.
or be 100% sure
you exhausted all options

Tinker and try to pinpoint exactly what's going on

stack exchange eth

2. check the documentation
3. google it

- Indexed Code-Based Forum : Stack overflow
- Indexed Repository : GitHub
- Indexed Technology-Specific Forum : r/ether (reddit)
- Unindexed Discussion Platform : chainlink discord channel

"Make your questions searchable and indexed by web crawlers"

And maybe build a new decentralized Stackoverflow please. Please build this.

ex)
I'm trying to find the best places to learn about smart contracts? Where should I look?

-> asking r/ethdev or probably more a "discord"
Why? -> It's Opinionated, Not Technical, etc

How do I undo 'git add' before commit?

I mistakenly ~...... ... ...
```
git add myfile.txt
```
I have not yet run `git commit`. Is there ~ ....

-> asking Stack Overflow

## Installation & Setup - Moving to local development

### HardHat

A smart contract developer framework similar to brownie or foundry or, and likes,

그리고 하드햇을 쓰는 이유는 바로 자바스크립트 기반이기때문입니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20200131.png)

타입스크립트를 좋아하는 분들을 위해서 코드 끝부분 마다 타입스크립트 버전의 코드를 보여드릴겁니다.

HardHat을 배우기 전에 먼저 배워야 할 패키지가 있습니다.

### Ethers.js

앞으로 Ethers.js로 할 수 있는 모든것들을 배울것입니다.
Ethers.js는 스마트 컨트렉트로 작업하기 위한 자바스크립트 기반의 라이브러리 입니다. 그리고 이 다음 배울 HardHat을 작동시킬 라이브러리기도 합니다.

HardHat 환경 안에는 많은 ethers.js가 있습니다. 그러니 ethers.js를 배우는것은 hardHat이 무엇을 하는지 이해하기 위해 굉장히 중요합니다.

## Local Development Introduction

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20224519.png)

설치

포메터 설정

`ctrl shift  p` -> `기본설정(settings.json)`

을 열고 다음줄을 추가합니다.

![](%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-06-07%20225257.png)


```solidity
    "[solidity]": {
        "editor.defaultFormatter": "NomicFoundation.hardhat-solidity"
    }
```
hardhat-solidity plulgin을 디폴트 포멧터로 설정
javascript는 prettier로

폴더에 전에 만들었던 SimpleStorage.sol 파일을 복사해서 넣어놓겠습니다.

## Tiny JavaScript Refresher

노드환경에서 자바스크립트를 실행시켜봅시다.

deploy.js를 만들고 다음과 같이 입력합니다.

```js
console.log("hi");
```

이제 터미널에서 node deploy.js 를 실행해봅시다.

터미널에서 tab키를 누르면 파일이름을 자동완성 시켜줍니다.

## Async Programming in JavaScript

솔리디티는 synchronous(동기) 프로그램밍 언어입니다.

동기가 뜻하는 것은 그저 다른것이 끝나면 한줄이 다시 시작되는 것입니다. 

```js
function main() {
  console.log("hi");
  let variable = 5;
  console.log(variable);
}

main();
```

만약 코드가 이렇게 되어있다면 이건 동기적으로 작성한겁니다. 

main()이 먼저 실행될 것이고, main안의 코드들이 한줄한줄 차례로 실행될겁니다.

이것이 자바스크립트의 동기형 프로그래밍이고 솔리디티는 모든 처리가 동기형으로 되어있습니다. 다만 오라클에서 작업할때는 예외가 있습니다.

그러나 지금은, 동기형으로 작동합니다.

자바스크립트는 비동기로 작동할 수 있습니다. 
이 말은 코드실행을 동시에 할 수 있다는 뜻입니다.

요리를 좋은 예시로 차이점에 대해서 설명해보겠습니다.

```tsx
요리

동기(Synchronous)
1. 팝콘을 전자레인지에 넣는다.
2. 팝콘이 완성될때까지 기다린다.
3. 다른 사람들을 위해 음료수를 준비한다.

```

여기서 이상한 점이 있다면, 굳이 이 순서대로 요리를 해야할까요?
`3. 다른 사람들을 위해 음료수를 준비한다` 는 `2. 팝콘이 완성될때까지 기다린다` 를 하면서 충분히 할 수 있는 일입니다. 팝콘이 다 될때까지 기다리지 않고, 음료수를 따르면 되겠죠?

```tsx
요리

비동기(Asynchronous)
1. 팝콘을 전자레인지에 넣는다.
2. 다른 사람들을 위해 음료수를 준비한다.
3. 팝콘이 완성될때까지 기다린다.
```

자바스크립트는 동기와 비동기의 전환이 자유롭습니다. 만약 `팝콘에 소금을 뿌린다` 라는 요리과정이 필요하다면 반드시 팝콘이 완성 된 후에 뿌려야 될 겁니다. 이럴땐 동기적으로 처리해야 되겠죠?

이렇게 대기시간이 있는 함수들은 `Promise`라고 불리는 객체를 반환합니다.

```tsx
요리

동기(Synchronous)
1. 팝콘을 전자레인지에 넣는다. -> `Promise`
2. 팝콘이 완성될때까지 기다린다.
3. 다른 사람들을 위해 음료수를 준비한다.

```

1.번이 자바스크립트 함수로 표현된다면 아마 `Promise` 기반의 함수가 될 겁니다. 프로미스(`Promise`)는 대기`pending`, 이행됨`fulfilled` 혹은 거절`reject` 도 가능합니다.

그리고 이런것들 덕분에 팝콘이 완성될 경우 그 사실을 알 수 있습니다.

팝콘이 메소드 일 경우, 

우리가 팝콘이 다 될 때까지 기다리는건 `pending` 상태입니다. 

팝콘이 다 되었다면 그건 `fulfilled` 상태일겁니다.

만약 도중에 그만 두고 기다림을 멈췄다면 `reject`상태일겁니다.

전자레인지에 팝콘을 넣는건 `Promise`입니다.
이 `Promise`를 가지고, 우리는 코드에게 이렇게 말 할 수 있습니다. "팝콘이 다 될때까지 기다려줄래요? 아니면 하던거 계속 해도 괜찮아요."

이제 이걸 자바스크립트로 표현해봅시다.

```js
불금 영화 세팅하기

팝콘 튀기기
음료수 따르기
영화 틀기

```

먼저 수도 코드로 이를 작성해보겠습니다.

```jsx
function 불금영화세팅하기() {
    팝콘튀기기()
    음료수따르기()
    영화틀기()
}
```
여기서 우리는 `영화틀기()`를 `팝콘튀기기()`와 `음료수따르기()`가 완료된 후에 실행하고 싶습니다.

팝콘튀기기와 음료수따르기 중 하나가 `Promise`를 반환한다면, 우리는 `불금영화세팅하기` 함수에게 기다려 달라고 팝콘을 다 튀길때까지 기다려달라고 말해야 합니다.
때문에 팝콘튀기기는 함수는 다음과 같이 표현할 수 있습니다.

```jsx
function 불금영화세팅하기() {
    let 상태 = 팝콘튀기기()
    음료수따르기()
    영화틀기()
}

function 팝콘튀기기() {
    //팝콘튀기는 코드
    return Promise(/*여기에 코드 입력*/)
}
```
그리고 팝콘이 튀겨지는 동안에 `상태`는 `완성`이 될것입니다. 즉 팝콘이 다 튀겨지면 `fulfilled` 로 될것이고, 팝콘이 망하고, 전자레인지가 폭발했다면 `reject` 상태가 될것입니다. 그런데 여기서 우리가 움직이기 전에 `상태`가 기다리는`pending`상태로 만들기는 싫습니다. 

영화가 시작되는 때는 오직 팝콘이 튀겨지고 음료수가 다 준비되었을 때 입니다.

그리고 `팝콘튀기기`와`음료수따르기` 둘다 `Promise`를 반환한다고 해봅시다. 그리고 코드에게 이렇게 말해야합니다. "팝콘이 다튀겨지고 음료수를 다 준비할때까지 기다려야해"

이렇게 하는 방법엔 2가지가 있습니다. 

그 중 가장 쉬운 방법은 `async` 함수로 만드는 것입니다.
async 함수를 사용한 함수 안에서는 `await`라 불리는 키워드에 접근할 수 있습니다. 

`await`를 가진 함수는 모든 `Promise`기반의 함수에게 `Promise`가 `fulfilled`되거나 `reject`될 때까지 기다려야한다고 알려줍니다.

여기서 await 팝콘튀기기() 함수를 fulfilled 되거나 reject 될때까지 기다리라는 뜻입니다.

그러면 이렇게 표현할 수 있습니다.

 팝콘이 튀겨질때까지 기다리고 `await 팝콘튀기기()`

그리고 나면 음료수가 다 준비될때까지 기다립니다. `await 음료수따르기()`

그리고 나서 나머지 작업 `영화틀기`를 실행합니다.

그리고 `영화틀기`는 반드시 위의 두가지 await 함수가 fulfilled 되거나 reject 되고 나서 실행됩니다.

```js
async function 불금영화세팅하기() {
    await 팝콘튀기기()
    await 음료수따르기()
    영화틀기()
}

function 팝콘튀기기() {
    //팝콘튀기는 코드
    return Promise(/*여기에 코드 입력*/)
}
```

이렇게 기억하면 됩니다. async 함수 안에서 만나는 await가 붙은 함수는 이 함수가 끝날때까지 다음 단계로 움직이지 않는구나. 라구요.

이렇게 살펴본 이유는 우리가 사용할 대부분의 함수들이 asyncronous로 작동하기 때문입니다.

예를들어, 우리가 계약을 배포할때 , 뭘 해야 하나요?

```js
async function deploy() {
    console.log("배포시작");
    //계약을 배포한다구? 배포가 완료될 때까지 기다려
}
```

만약 async를 사용하지 않으면 어떻게 될까요?

```js
function deploy() {
    console.log("배포시작");
    //계약을 배포한다구? 배포가 완료될 때까지 기다려
    //contract.deploy -> 배포가 끝날때까지 기다리지 않음
}
```
이렇게 된다면 배포가 끝나지 않은상태에서 컨트렉트 안의 코드를 실행시키게 되고 작동하지 않게 될 겁니다.

```js
async function deploy() {
    console.log("배포시작");
    //계약을 배포한다구? 배포가 완료될 때까지 기다려
    //contract.deploy -> 배포가 끝날때까지 기다림
}
```

그리고 이제 우리의 main()함수에 코드를 적어줄겁니다.

```js
async function main() {
    console.log("hi");
}

main().then(() => process.exit(0)).catch((error)=>{
    console.error(error);
    process.exit(1);
})
```

이것이 기본적으로 완료될떄까지 기다렸다가 에러를 출력하도록 만드는 코드입니다.

## Compiling our Solidity