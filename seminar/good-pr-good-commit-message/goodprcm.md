# 좋은 커밋 메세지 & 좋은 풀 리퀘스트

# 좋은 커밋 메세지

## 커밋 메세지란?

모든 소프트웨어 프로젝트는 협동 프로젝트입니다.

나 혼자 개발을 하더라도 몇달 후 내가 짠 코드가 무엇을 하는지 알아내야하는 경우가 있죠.

미래의 내가 새로운 기능을 추가하거나 버그가 발생하여 고쳐야할때 코드이 맥락을 다시 파악해야 합니다.

**코드조각을 다시 파악하는 일 -> 낭비!**

이 시간을 최소화할 수 있도록 노력해야 합니다!

***커밋메시지*** 가 바로 이 역할을 합니다!

## 커밋메시지를 보면 좋은 개발지인지 아닌지 알 수 있다?

```
6개월 전 나의 커밋
"옛날꺼로 되돌림" +986 addition -975 deletion
```
"이게 뭔소리이야 뭔 짓을 한거야"

한눈에 봐서는 무엇을 어떻게 고쳤는지 알 수 가 없습니다.

코드 코멘트나 추적할 수 없는 히스토리가 없다면 앞이 깜깜할 겁니다. 

더구나 어떤 라인을 지우면 전체 프로덕트가 망가져버리지 않을까하는 걱정까지 생깁니다.

## 좋은 커밋 메세지를 작성하는 목적

1. 리뷰 프로세스를 빠르게 만듭니다.
2. 좋은 릴리즈 노트를 만들 수 있습니다.
3. 미래의 코드 메인테이너(유지보수관리자)를 도울 수 있습니다. (심지어 그게 나 자신일수도 있습니다!)

## 좋은 커밋 메세지!

다음의 세가지 질문에 답할 수 있어야 합니다.

#### 1. 왜 이코드가 필요한가요?
    - 버그수정
    - 기능 추가
    - 성능 향상
    - 신뢰성, 안정성을 위한 변경
    - 단순한 오탈자 교정

#### 2. 어떻게 이슈를 해결했나요?
    - 짧아서 명백한 부분은 생략가능
    - 깊은 수준 묘사로 어떻게 문제에 접근했는지 표기

#### 3. 패치가 어떤 영향을 미치나요?
    - 명백한 부분을 포함한 벤치마크 결과
    - 부작용 등

### 위 세가지 질문으로 알 수 있는 점

1. 코드 변경에 대한 맥락을 파악할 수 있습니다.
2. 리뷰어와 다른 개발자가 맥락을 파악하고 적절한 방법을 선택했는지 알 수 있습니다.
3. 유지보수 관리자가 배포를 결정할 수 있도록 도와줍니다.

### 세가지 질문에 답이 없는 메시지라면?
 - 페치가 어떤일을 했고, 어떻게 이슈를 해결했는지 리뷰어가 직접 찾아야하기 때문에 부담만 가중됩니다.

 - 때문에 많은 인력(리뷰어)가 이를 파악하기 위해 나서야 합니다.

 - 좋은 커밋 메시지를 작성하지 않았다는 이유 하나로 수많은 인력이 낭비가 됩니다.

 - 메인테이너가 관리 통제를 철저히 한다면 당연히 반려될 것이고, 개발자는 다시 시간을 소비해 패치를 작성해야합니다. (결과적으로 일을 두번 하게됩니다.)

좋은 커밋 메세지 하나가 이와 같은 문제들을 해결 할 수 있습니다! 

## 어떻게 해야 좋은 커밋 메세지를 작성 할 수 있을까요?

단 한가지의 이상적인 방법은 없지만, 일반적인 규칙이 있습니다.

1. 커밋은 정확히 하나의 변경사항만 포함합니다.
2. 로직변경이란, 기능을 추가하거나 버그를 수정함을 의미합니다.
3. 몇개의 단어로 변화를 표현할 수 없다면 단일 커밋만으로 부족한 상태라는 뜻입니다.
4. 변경은 가능한 스스로 이해할 수 있도록 간결해야 합니다.
5. 무엇보다 커밋 메시지만 읽어도, 다른 개발자가 비슷한 시간을 들여 같은 패치를 구현할 수 있어야 합니다.
6. git을 사용한다면 `git add -p` `git add -i`를 활용해 각각의 변경사항에 따라 단일 커밋 단위로 쪼개야 합니다.

## Git 커밋 양식

1. 첫 행은 변경에 대한 요약 (행의 최대 길이는 행 당 50자에서 70자)
2. 첫 줄을 가장 많이보고 가장 중요함
3. 첫 행 요약 다음 빈 행 입력, 그 다음 필요에 따라 상세 내역을 여러 문단으로 작성
4. 코드 설명이 아닌 **의도와 접근 방식**을 설명
5. 로그는 현재형으로 작성

## 커밋할 때 하면 안되는 것

1. 소스컨트롤 관리를 백업시스템처럼 쓰기 : 퇴근 전 커밋
2. 파일 당 커밋 : 로직이 변경되지 않았음에도 커밋
3. 게으른 커밋 메세지 : "여러가지 고치고 정리했음~ 끝"
4. 하나의 패치 안에 두가지 변경점 : "버그 abc를 고치고 모든 foo를 bar로 수정했음"
5. 코드 변경에 공백 변경을 함께 넣는 경우 : 공백 변경이 커밋변경사항으로 들어가는 경우 버그를 찾기가 정말 힘듬
6. 코드 폭탄 : 수백줄의 코드를 수정하여 새 기능을 덤프하느 동시에 이 기능이 동작하게 만들기 위해 기존 코드의 절반을 다시 작성하는 경우

모든 업보는 나에게 부메랑처럼 돌아옵니다...

코드는 반드시 수정됩니다! 최초로 코드를 작성한 사람 조차 훗날 왜 그랬는지 모를 수 있고, 그 누구도 모를 수 도 있습니다. 최악의 경우 모든 사람들이 코드가 어떻게 작동하는지 몰라서 코드 접근에 대해 두려워할 수 도 있습니다. 

## 커밋 메세지 작성해보기

커밋 메시지에는 다양한 방식이 있지만

최우선 순위는 당연히 **팀의 컨벤션** 입니다!

```ps1
#BASIC:
git commit -m <message>
```

```ps1
#Detailed:
git commit -m <title> -m <description>
```

### 더 좋은 커밋메세지를 위한 5가지 방법

1. 첫글자는 항상 대문자로, 끝은 마침표를 찍지 않습니다.
2. 명령조로 입력합니다. 
    - ex) Add fix for dark mode toggle state. fixed(x) fix(o)
3. 커밋 형태: 커밋 형태를 특정하는게 좋습니다.
    - ex) bug fix, update, refactor, bump ... 
4. 길이: 첫 줄은 50자를 넘기지 않는것이 이상적입니다, 본문은 72자가 넘지 않도록 해야합니다.

5. 내용: 직설적으로 표현하고 형용사나 미사여구등을 제거하도록 합시다. (ex: 그래도, 아마, 내생각에, 일종의…) 마치 *기자* 차럼 쓰면 됩니다.

### 기자처럼 쓰는 방법

저널리스트들은 작성한 기사가 디테일하고, 직관적이고, 그리고 독자의 궁금증에 대해 답변이 될 수 있는지 스스로 물어봅니다.

그리고 누가, 어떻게, 어디서, 언제, 왜, 그리고 어떻게 로 나누어 작성합니다.

커밋메세지를 작성할때는 무엇(What)과 왜(Why)가 제일 중요한 부분입니다.

의미있는 커밋은 다음과 같은 특징을 가지고 있습니다.

1. 왜 이렇게 변경했나요?
2. 이 변경이 무슨 영향을 끼치나요?
3. 왜 이 변경이 필요한가요?
4. 어디를 변경했나요?

커밋 메세지를 보는 사람이 변경에 대한 맥락을 모른다고 가정해봅시다.

```ps1
# 1.
git commit -m "Add margin"

# 2.
git commit -m "Add margin to nav items to prevent them from overlapping the logo"
```

둘 중 유용한 것은 2번일 것입니다.

## 컨벤셔널 커밋

미리 약속된 형태로 커밋을 작성하는 방법입니다.

```ps1
<type>[optional scope]: <description>

[optional body]

[optional footer]
```

### 커밋 TYPE

커밋의 `type`에는 다음과 같은 것들이 올 수 있습니다.

- `feat`  변경사항과 함께 새로운 기능이 추가되었을때

- `fix`  버그 수정이 발생했을때

- `chore`  변경사항이 fix혹은 feature와 관련이 없고 소스(src)나 테스트파일을 변경하지 않았을때 (ex: 패키지 디펜던시 업데이트)

- `refactor` 버그 수정, 기능수정 없는 상태의 리팩터링 된 코드

- `docs` README 파일 혹은 다른 마크다운 파일과 같은 개발문서를 업데이트 했을때

- `style` 코드의 의미에 영향을 끼치지 않는 변화, 예를 들어 공백이나 세미콜론 등등의 코드 포멧팅

- `test` 새로운 테스트 또는 수정된 이전 테스트를 포함시켰을 때

- `perf` 성능 향상이 포함되었을 때

- `ci` CI(배포자동화) 관련 코드가 수정되었을 때

- `build` 빌드 시스템이나 외부 dependency 에 영향을 주는 변경사항

- `revert` 이전 커밋을 되돌렸을때

### 커밋 본문
본문은 `{타입}(적용범위): 메시지` 로 표현할 수 있는 상세한 내용을 적는 부분입니다.

따라서 `{타입}(적용범위): 메시지` 만으로 표현할 수 있다면 생략이 가능합니다.

하지만 Major 버전에 대한 명시라면 반드시 표기해야합니다.

`BREAKING CHANGE: 설명`은 해당 커밋에서 중대한(Major) 변화가 있음을 나타냅니다.

즉, 큰 변경사항 때문에 어떠한 부분들과 호환 될 수 없음을 뜻합니다.

또한 `BREAKING CHANGE`를 못보고 지나칠 가능성이 있기 때문에 제목에 `!`를 이용해서 항상 `BREAKING CHANGE`를 명시하도록 합니다.

`{타입}(적용범위)!: <메세지>`

```ps1
#{타입}(적용범위)!: <메세지>
Feat(pipeline)!: Add pipeline function
```

푸터는 선택사항입니다. 지라 이슈를 연결하여 다음과 같이 관리 할 수 도 있습니다.

`Closes PLAYV-<JIRA #>`

```ps1
fix: fix foo to enable bar

This fixes the broken behavior of the component by doing xyz. 

BREAKING CHANGE
Before this fix foo wasn't enabled at all, behavior changes from <old> to <new>

Closes PLAYV-999
```

컨벤셔널 커밋을 지키면 얻는 장점?

1. 커밋을 하나의 목표에 대한 수정사항 단위로 관리가능
2. 커밋 메시지만으로 어떠한 것에 대한 커밋인지 확인 가능
3. CHANGE LOG 생성 자동화 -> 릴리즈 노트 일관적이고 명확하게 작성가능
4. 시멘틱 버전관리를 명확하게 가능, 

### 커밋

- 현재 진행중인 프로젝트의 스냅샷
- 커밋 하나는 해당 프로젝트의 독립적인 버전
- 커밋마다 


# 좋은 풀 리퀘스트

## 풀 리퀘스트 작성 원칙

https://github.blog/2015-01-21-how-to-write-the-perfect-pull-request/

### 풀 리퀘스트 작성방법
1. 목적을 포함해주세요
    - 이것은 ~ 을 탐색하기 위한 스파이크 입니다
    - 이렇게 하면 ~ 의 표시가 간단해집니다.
    - 이렇게 하면 ~ 가 수정됩니다.
2. 작업이 진행되는 이유와 개요를 제공해주세요(링크포함). 누구나 이 작업의 히스토리에 익숙하지 않습니다.
3. 회사의 모든 사람이 이 풀 리퀘스트를 읽을 수 있다는 점을 기억하세요. 작성한 내용과 어조(톤)는 지금 참여하는 사람들 뿐만 아니라 추후에 다른 외부의 사람들에게도 알려질 수 있습니다.
4. 원하는 피드백이 있다면 확실히 명시해주세요. 코드에 대한 기술적인 접근방식, 디자인에 대한 비평, 사본에 대한 리뷰
5. 언제 피드백을 받고 싶은지 시간을 명시해 주세요. 만약 풀리퀘스트가 진행중이라면 진행중이라 말해주세요 `[WIP]`(Work In Progress)은 일반적이고 간단하게 상태를 나타내는 방법입니다.
6. `@mention`을 이용해 토론에 참여시키고 언급하고 싶은 사람을 지목하고 이유를 설명해주세요. (ex) `/cc bclabs-abc 로직 설명 필요`)
7. 마찬가지로 토론에 참여시키고 싶은 팀이 있다면 @mention을 이용해 설명해주세요 (ex: `/cc @bclabs/production, 이 로직에 대해 걱정되는점이 있나요?`)

### 피드백 하기

1. 풀 리퀘스트가 만들어진 이유와 문제의 맥락을 파악하고 숙지합니다.
2. 의견에 대해 강력히 반대한다면, 응답하기 전에 조금 여유를 가져보세요, 행동하기 전에 한번 더 생각해봅시다.
3. 명령보다는 부탁합시다. (Ex: 이렇게 하지 마세욧! -> 이렇게 하시는건 어때요?
4. 왜 코드가 바뀌어야 하는지 설명해주세요. (스타일가이드에 맞지 않네요, 개인적으로 별루…)
5. 코드를 단순화하거나 개선하는 방법을 제공합니다.
6. 다른 사람의 작업에 대해 경멸적인 용어를 사용하지 말아주세요.
7. “절대” 같이 과장된 말을 피해주세요 (“절대 이런식으로 하지마세요~”)
8. 크리틱은 항상 전문적인 스킬, 그룹 지식 그리고 프로덕트 퀄리티 향상을 목표로 하세요. 
9. 온라인 커뮤니티 등지에서의 부정적인 편견에 대해 경계하세요. 긍정적(중립적)으로 말할 수 있는지 생각해봅시다.
10. 이모티콘을 통해 톤을 명확히 하면 좋습니다. (Ex: 좋아요 vs ✨✨✨좋아요😍👍)

### 피드백에 응답하기

1. 피드백들의 의견이 엇갈릴 경우, 감사의 표현을 위주로 작성하도록 합니다.
2. 잘 모르는것에 대해 설명을 부탁합니다. (“잘 모르겠는데 자세히 설명해 주실 수 있나요?”)
3. 설명을 제공하고 문제를 해결하기 위해 내린 결정에 대해 설명합니다.
4. 되도록 모든 의견에 응답하도록 노력합시다.
5. 후속 커밋이나 풀리퀘스트의 링크를 제공해줍시다.
6. 혹시 혼란이나 논쟁이 가중되고 있다면, 쓰여진 내용이 의사소통에 적절한지 한번 더 생각해봐야합니다. 직접 만나서 얘기한 다음 결과를 요약해서 후속조치를 포스팅하는 것에 대해 고려해봅시다.

**이러한 지침들은 회사가 일하는 방식이나 키워나가고자 하는 문화의 방향에 따라 달라질 수 있습니다.**

### 좋은 피드백과 나쁜 피드백의 예

#### Good examples:
```
this won't work because the function is async.
함수가 async 이므로 작동하지 않을 겁니다.

this file should go to components/shared because this is an atom component and can be reused on another page
이 파일은 components/shared 로 옮겨야합니다. atom 컴포넌트이고 다른 페이지에서 재사용할 수 있기 때문입니다.

I'm not sure this does what it's meant to do. Looking at the service as a whole the code should probably allow the end user to construct this out of exported functions.
이게 정확히 어떤 일을 하는지 모르겠습니다. 서비스 전반적으로 본다면 코드는 최종사용자가 내보낸 함수를 구축할 수 있도록 허락해야합니다.
```
Bad examples:
```
can you please update this function documentation as well?
이거 잘 문서화해서 올려줄 수 없나요?

this is not according to our guidelines
우리 가이드라인에 맞지 않아요

naming is not correct here
네이밍이 맞지 않네요

pls fix.
고쳐주세요.
```

## 풀리퀘스트를 나누어서 보내야하는 이유

클린코드를 작성하는 것은 풀리퀘스트를 만들때 고려해야할 여러가지 이유중 한가지에 불과합니다.

거대한 풀리퀘스트는 코드리뷰와 버그수정에 있어서 과부하를  발생시킵니다.

이러한 이유로 풀리퀘스트 자체에 대해 신경써야합니다. 짧고, 명확한 제목과 내용이 있어야하며, 딱 한가지의 일만 수행해야합니다.

왜 신경써야 하나요?

1. 좋은 풀리퀘스트는 리뷰가 빠릅니다.
2. 코드베이스에 버그가 발생되지 않도록 방지해줍니다.
3. 신규 개발자의 온보딩에 유리합니다.
4. 다른 개발자의 접근을 막지 않습니다.
5. 코드 검토 과정의 속도를 높이고 결과적으로 프로덕트 개발 속도를 높일 수 있습니다.


플 리퀘스트 크기

첫번째 단계는 큰 차이점을 찾는 것입니다.

연구에 따르면 많은 량의 코드를 검토할 수록 버그 찾기가 어렵다고 합니다.

또한 대규모의 플 리퀘스트는 코드에 의존할 수 있는 다른 개발자들을 차단하게 됩니다.

### 풀리퀘스트 크기 결정하기

통계에 따르면 60~90분에 걸쳐 200~400 개의 LOC(Line of Code)을 검토한 결과 70~90%의 결함이 발견되었습니다.

이 숫자에 따르면 **좋은 풀리퀘스트는 250줄 이상의 코드가 변경되어서 안됩니다.**


### 큰 풀리퀘스트를 작게 쪼개기

더 많이 쪼갤 수록 쉽게 내용을 숙지할 수 있습니다.

기능 조깨기란 무엇일까요??

큰 기능을 이해하고 작은 기능으로 나누어 각각이 의미를 가지고 코드베이스에 손상을 주지 않고 조각단위로 머지(merge)가 가능함을 의미합니다.

예를 들어 여러분이 앱에 구독 기능을 만들어야 한다고 가정해봅시다.

이메일 주소를 받고 저장하는 폼을 구현할겁니다.

여러분의 앱이 어떻게 작동하는지 모르더라도 다음과 같이 8가지로 풀 리퀘스트를 쪼갤 수 있습니다.

1. 이메일을 저장하기 위한 model 생성
2. 요청을 받을 라우트 생성
3. 컨트롤러 생성
4. 데이터베이스에 저장하기 위한 서비스 생성 (비즈니스 로직)
5. 접근 제한을 위한 정책 생성
6. 구독 컴포넌트 생성(프론트엔드)
7. 구독 컴포넌트를 호출하는 버튼 생성
8. 인터페이스에 구독 버튼 추가하기


보시다시피 한가지 기능을 많은 단위로 나눌 수 있습니다. 이중 대부분은 다른 개발자들이 동시에 진행할 수 있습니다.



### 단일 책임 원칙

Single responsibility principle(SRP) 는 모듈이나 클래스가 반드시 한가지의 기능에 대해서만 책임을 가져야한다는 원칙입니다. 

풀리퀘스트도 마찬가지 입니다.

단일 책임 원칙을 지킬 수록 여러 코드를 수정하려 할때 발생하는 혼란을 막을 수 있습니다.

PR을 날리기 전에 코드가 한가지 이상의 일을 하고 있다면 다른 풀리퀘스트로 나눠주세요.

### 제목과 설명

PR제목은 스스로를 설명할 수 있어야 합니다.

Ex) 

https://github.com/facebook/react/pull/12755

https://github.com/facebook/react/pull/12421


무엇이 바뀌었는지 설명합니다.
이 PR이 왜 존재하는지 설명합니다.
무엇이 생기고 무엇이 없어졌는지 확실히 하세요.
스크린샷을 이용해 변경점을 설명하세요


요약:

풀리퀘스트 크기 : 작아야합니다, 변경점이 250줄 이내여야 합니다.

기능 나누기: 가능하다면, 풀리뭬스트를 조그마한 조각으로 나눠주세요.

단일책임원칙: 풀리퀘스트는 한가지 일만을 다뤄야합니다.

제목: 풀리퀘스트가 무엇을 하는지 스스로 설명할 수 있어야합니다.

본문: 무엇이 바뀐지에 대한 상세한 설명, 왜 바뀌었는지, 어떻게 바뀌었는지 설명합니다.

## 좋은 풀 리퀘스트 작성하기

출처:

https://www.pullrequest.com/blog/writing-a-great-pull-request-description/


템플릿:
```
## 무엇을?

## 왜?

## 어떻게?

## 테스트 했나요?

## 스크린샷 (선택사항)

## 그 밖에 다른것들은?
```


로켓을 만드는 것도 아니고 컴퓨터 공학도 아닙니다. 단지 명확하고 알기 쉬운 시놉시스를 작성하는 일입니다.

### 무엇을 (The What)

여러분의 변경사항을 설명하세요. 멋지게 꾸밀 필요는 없습니다. 아직은 기술적으로 접근하지 않아도 됩니다. 고수준에서 리뷰어에게 PR의 전반적인 변경사항을 알리면 됩니다. 

해당 되는 이슈트래커에서 티켓을 참조로 넣어도 되지만, 반드시 티켓’만’ 참조하지는 마세요.



변경사항을 먼저 설명하고 티켓을 참조하여야 합니다.



리뷰어가 코드리뷰를 하는데 적은 시간을 할애할 수록 리뷰어에게 좋은 경험을 줄 수 있습니다.



다음은 잘못된 “무엇을” 에 대한 예시 입니다.



```ps1

## What ?

Support for #JIRA-123

## What ?

Added table to support #JIRA-567

## What ?

See the subject.

```



조금 더 나은 설명



```

## What ?

Added support for authentication. #JIRA-123.

```



훨씬 더 나은 설명



```

## What?

I've added support for authentication to implement Key Result 2 of OKR1. It includes model, table, controller and test. For more background, see ticket #JIRA-123.

OKR1의 Key Result 2를 구현하기 위해 인증 지원을 추가했습니다. 여기에는 모델, 테이블, 컨트롤러 및 테스트가 포함됩니다. 자세한 정보는 티켓 #JIRA-123을 참조하십시오.

```



이해하는데 몇 초 이상 필요하지 않은 짧고 간결한 문장으로 변경사항을 명확하게 나타내려 노력해야 합니다.



### 왜(WHY)

실질적인 코드 변경을 나타냅니다.

변경 “이유”는 이 변경이 달성하려는 비즈니스 또는 엔지니어링 목표를 알려줍니다.

간단한 환경변수 기본값을 추가하는 상황을 가정해봅시다.

## 어떻게 (HOW)

물론 PR diff 가 "어떻게"에 대한 대부분의 설명을 해줄겁니다. 하지만 디자인적인 부분에 주의를 기울여야 합니다. 예를 들어 루프대신 재귀 메소드를 사용한다했을때, 리뷰어에게 재귀메소드의 이점을 설명한다면 리뷰어가 여러분의 의도를 쉽게 파악하여 훨씬 더 나은 리뷰를 제공받을 수 있을겁니다.

Bad:
```ps1
## How?
Wrote migration and model.

마이그레이션과 모델 작성
```

이건 코드를 보면 명백히 나와있는 사실입니다. 리뷰어를 좀 더 도와줍시다.

Good:
```
## How?
This includes a migration, model and controller for user authentication. I'm using Devise to do the heavy lifting. I ran Devise migrations and those are included here.

여기에는 사용자 인증을 위한 마이그레이션이 포함됩니다. 무거운 작업에는 Devise를 사용하고 있습니다. Devise 마이그레이션을 실행했으며 여기에 포함되어있습니다.
```
### 풀 리퀘스트는 사람을 위한것

항상 간결함을 유지하세요. 코드를 작성하는것이 아니라 사람과 의사소통하려하는 것입니다. 길고 복잡한 설명은 상대방을 피곤하게 할 뿐입니다. 짧고 간결하게 작성하여 PR 리뷰어의 흥미를 유발하고 과정을 원할하게 진행 할 수 있도록 합시다.