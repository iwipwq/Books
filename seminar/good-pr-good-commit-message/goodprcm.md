# 좋은 커밋 메세지 & 좋은 풀 리퀘스트

# 좋은 커밋 메세지

## 커밋 메세지란?

모든 소프트웨어 프로젝트는 협동 프로젝트입니다.

나 혼자 개발을 하더라도 몇달 후 내가 짠 코드가 무엇을 하는지 알아내야하는 경우가 있죠.

미래의 내가 새로운 기능을 추가하거나 버그가 발생하여 고쳐야할때 코드이 맥락을 다시 파악해야 합니다.

**코드조각을 다시 파악하는 일 -> 낭비!**

이 시간을 최소화할 수 있도록 노력해야 합니다!

***커밋메시지*** 가 바로 이 역할을 합니다!

## 커밋메시지를 보면 좋은 개발지인지 아닌지 알 수 있다?

```
6개월 전 나의 커밋
"옛날꺼로 되돌림" +986 addition -975 deletion
```
"이게 뭔소리이야 뭔 짓을 한거야"

한눈에 봐서는 무엇을 어떻게 고쳤는지 알 수 가 없습니다.

코드 코멘트나 추적할 수 없는 히스토리가 없다면 앞이 깜깜할 겁니다. 

더구나 어떤 라인을 지우면 전체 프로덕트가 망가져버리지 않을까하는 걱정까지 생깁니다.

## 좋은 커밋 메세지를 작성하는 목적

1. 리뷰 프로세스를 빠르게 만듭니다.
2. 좋은 릴리즈 노트를 만들 수 있습니다.
3. 미래의 코드 메인테이너(유지보수관리자)를 도울 수 있습니다. (심지어 그게 나 자신일수도 있습니다!)

## 좋은 커밋 메세지!

다음의 세가지 질문에 답할 수 있어야 합니다.

#### 1. 왜 이코드가 필요한가요?
    - 버그수정
    - 기능 추가
    - 성능 향상
    - 신뢰성, 안정성을 위한 변경
    - 단순한 오탈자 교정

#### 2. 어떻게 이슈를 해결했나요?
    - 짧아서 명백한 부분은 생략가능
    - 깊은 수준 묘사로 어떻게 문제에 접근했는지 표기

#### 3. 패치가 어떤 영향을 미치나요?
    - 명백한 부분을 포함한 벤치마크 결과
    - 부작용 등

### 위 세가지 질문으로 알 수 있는 점

1. 코드 변경에 대한 맥락을 파악할 수 있습니다.
2. 리뷰어와 다른 개발자가 맥락을 파악하고 적절한 방법을 선택했는지 알 수 있습니다.
3. 유지보수 관리자가 배포를 결정할 수 있도록 도와줍니다.

### 세가지 질문에 답이 없는 메시지라면?
 - 페치가 어떤일을 했고, 어떻게 이슈를 해결했는지 리뷰어가 직접 찾아야하기 때문에 부담만 가중됩니다.

 - 때문에 많은 인력(리뷰어)가 이를 파악하기 위해 나서야 합니다.

 - 좋은 커밋 메시지를 작성하지 않았다는 이유 하나로 수많은 인력이 낭비가 됩니다.

 - 메인테이너가 관리 통제를 철저히 한다면 당연히 반려될 것이고, 개발자는 다시 시간을 소비해 패치를 작성해야합니다. (결과적으로 일을 두번 하게됩니다.)

좋은 커밋 메세지 하나가 이와 같은 문제들을 해결 할 수 있습니다! 

## 어떻게 해야 좋은 커밋 메세지를 작성 할 수 있을까요?

단 한가지의 이상적인 방법은 없지만, 일반적인 규칙이 있습니다.

1. 커밋은 정확히 하나의 변경사항만 포함합니다.
2. 로직변경이란, 기능을 추가하거나 버그를 수정함을 의미합니다.
3. 몇개의 단어로 변화를 표현할 수 없다면 단일 커밋만으로 부족한 상태라는 뜻입니다.
4. 변경은 가능한 스스로 이해할 수 있도록 간결해야 합니다.
5. 무엇보다 커밋 메시지만 읽어도, 다른 개발자가 비슷한 시간을 들여 같은 패치를 구현할 수 있어야 합니다.
6. git을 사용한다면 `git add -p` `git add -i`를 활용해 각각의 변경사항에 따라 단일 커밋 단위로 쪼개야 합니다.

## Git 커밋 양식

1. 첫 행은 변경에 대한 요약 (행의 최대 길이는 행 당 50자에서 70자)
2. 첫 줄을 가장 많이보고 가장 중요함
3. 첫 행 요약 다음 빈 행 입력, 그 다음 필요에 따라 상세 내역을 여러 문단으로 작성
4. 코드 설명이 아닌 **의도와 접근 방식**을 설명
5. 로그는 현재형으로 작성

## 커밋할 때 하면 안되는 것

1. 소스컨트롤 관리를 백업시스템처럼 쓰기 : 퇴근 전 커밋
2. 파일 당 커밋 : 로직이 변경되지 않았음에도 커밋
3. 게으른 커밋 메세지 : "여러가지 고치고 정리했음~ 끝"
4. 하나의 패치 안에 두가지 변경점 : "버그 abc를 고치고 모든 foo를 bar로 수정했음"
5. 코드 변경에 공백 변경을 함께 넣는 경우 : 공백 변경이 커밋변경사항으로 들어가는 경우 버그를 찾기가 정말 힘듬
6. 코드 폭탄 : 수백줄의 코드를 수정하여 새 기능을 덤프하느 동시에 이 기능이 동작하게 만들기 위해 기존 코드의 절반을 다시 작성하는 경우

모든 업보는 나에게 부메랑처럼 돌아옵니다...

코드는 반드시 수정됩니다! 최초로 코드를 작성한 사람 조차 훗날 왜 그랬는지 모를 수 있고, 그 누구도 모를 수 도 있습니다. 최악의 경우 모든 사람들이 코드가 어떻게 작동하는지 몰라서 코드 접근에 대해 두려워할 수 도 있습니다. 

## 커밋 메세지 작성해보기

커밋 메시지에는 다양한 방식이 있지만

최우선 순위는 당연히 **팀의 컨벤션** 입니다!

```ps1
#BASIC:
git commit -m <message>
```

```ps1
#Detailed:
git commit -m <title> -m <description>
```

### 더 좋은 커밋메세지를 위한 5가지 방법

1. 첫글자는 항상 대문자로, 끝은 마침표를 찍지 않습니다.
2. 명령조로 입력합니다. 
    - ex) Add fix for dark mode toggle state. fixed(x) fix(o)
3. 커밋 형태: 커밋 형태를 특정하는게 좋습니다.
    - ex) bug fix, update, refactor, bump ... 
4. 길이: 첫 줄은 50자를 넘기지 않는것이 이상적입니다, 본문은 72자가 넘지 않도록 해야합니다.

5. 내용: 직설적으로 표현하고 형용사나 미사여구등을 제거하도록 합시다. (ex: 그래도, 아마, 내생각에, 일종의…) 마치 *기자* 차럼 쓰면 됩니다.

### 기자처럼 쓰는 방법

저널리스트들은 작성한 기사가 디테일하고, 직관적이고, 그리고 독자의 궁금증에 대해 답변이 될 수 있는지 스스로 물어봅니다.

그리고 누가, 어떻게, 어디서, 언제, 왜, 그리고 어떻게 로 나누어 작성합니다.

커밋메세지를 작성할때는 무엇(What)과 왜(Why)가 제일 중요한 부분입니다.

의미있는 커밋은 다음과 같은 특징을 가지고 있습니다.

1. 왜 이렇게 변경했나요?
2. 이 변경이 무슨 영향을 끼치나요?
3. 왜 이 변경이 필요한가요?
4. 어디를 변경했나요?

커밋 메세지를 보는 사람이 변경에 대한 맥락을 모른다고 가정해봅시다.

```ps1
# 1.
git commit -m "Add margin"

# 2.
git commit -m "Add margin to nav items to prevent them from overlapping the logo"
```

둘 중 유용한 것은 2번일 것입니다.

## 컨벤셔널 커밋

미리 약속된 형태로 커밋을 작성하는 방법입니다.

```ps1
<type>[optional scope]: <description>

[optional body]

[optional footer]
```

### 커밋 TYPE

커밋의 `type`에는 다음과 같은 것들이 올 수 있습니다.

- `feat`  변경사항과 함께 새로운 기능이 추가되었을때

- `fix`  버그 수정이 발생했을때

- `chore`  변경사항이 fix혹은 feature와 관련이 없고 소스(src)나 테스트파일을 변경하지 않았을때 (ex: 패키지 디펜던시 업데이트)

- `refactor` 버그 수정, 기능수정 없는 상태의 리팩터링 된 코드

- `docs` README 파일 혹은 다른 마크다운 파일과 같은 개발문서를 업데이트 했을때

- `style` 코드의 의미에 영향을 끼치지 않는 변화, 예를 들어 공백이나 세미콜론 등등의 코드 포멧팅

- `test` 새로운 테스트 또는 수정된 이전 테스트를 포함시켰을 때

- `perf` 성능 향상이 포함되었을 때

- `ci` CI(배포자동화) 관련 코드가 수정되었을 때

- `build` 빌드 시스템이나 외부 dependency 에 영향을 주는 변경사항

- `revert` 이전 커밋을 되돌렸을때

### 커밋 본문
본문은 `{타입}(적용범위): 메시지` 로 표현할 수 있는 상세한 내용을 적는 부분입니다.

따라서 `{타입}(적용범위): 메시지` 만으로 표현할 수 있다면 생략이 가능합니다.

하지만 Major 버전에 대한 명시라면 반드시 표기해야합니다.

`BREAKING CHANGE: 설명`은 해당 커밋에서 중대한(Major) 변화가 있음을 나타냅니다.

즉, 큰 변경사항 때문에 어떠한 부분들과 호환 될 수 없음을 뜻합니다.

또한 `BREAKING CHANGE`를 못보고 지나칠 가능성이 있기 때문에 제목에 `!`를 이용해서 항상 `BREAKING CHANGE`를 명시하도록 합니다.

`{타입}(적용범위)!: <메세지>`

```ps1
#{타입}(적용범위)!: <메세지>
Feat(pipeline)!: Add pipeline function
```

푸터는 선택사항입니다. 지라 이슈를 연결하여 다음과 같이 관리 할 수 도 있습니다.

`Closes PLAYV-<JIRA #>`

```ps1
fix: fix foo to enable bar

This fixes the broken behavior of the component by doing xyz. 

BREAKING CHANGE
Before this fix foo wasn't enabled at all, behavior changes from <old> to <new>

Closes PLAYV-999
```

컨벤셔널 커밋을 지키면 얻는 장점?

1. 커밋을 하나의 목표에 대한 수정사항 단위로 관리가능
2. 커밋 메시지만으로 어떠한 것에 대한 커밋인지 확인 가능
3. CHANGE LOG 생성 자동화 -> 릴리즈 노트 일관적이고 명확하게 작성가능
4. 시멘틱 버전관리를 명확하게 가능, 

### 커밋

- 현재 진행중인 프로젝트의 스냅샷
- 커밋 하나는 해당 프로젝트의 독립적인 버전
- 커밋마다 
